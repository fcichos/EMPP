{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Solving ODEs\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "All the stuff we have defined in the previous sections is useful for solving ordinary differential equations. This will bring us closer to solving out physics problems now.\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import io\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.sparse import diags\n",
        "\n",
        "# default values for plotting\n",
        "plt.rcParams.update({'font.size': 12,\n",
        "                     'lines.linewidth': 1,\n",
        "                     'lines.markersize': 5,\n",
        "                     'axes.labelsize': 11,\n",
        "                     'xtick.labelsize' : 10,\n",
        "                     'ytick.labelsize' : 10,\n",
        "                     'xtick.top' : True,\n",
        "                     'xtick.direction' : 'in',\n",
        "                     'ytick.right' : True,\n",
        "                     'ytick.direction' : 'in',})\n",
        "\n",
        "def get_size(w,h):\n",
        "      return((w/2.54,h/2.54))\n",
        "```\n",
        "\n",
        "## Harmonic Oscillator\n",
        "\n",
        "\n",
        "::: {.callout-note}\n",
        "## Physics Interlude: The harmonic oscillator\n",
        "\n",
        "We are going to tackle as a first very simple problem, the harmonic oscillator and we will demonstrate that with the matrix (Crank-Nicholson method or implicit scheme), the Euler type integration method and using some 'unknown' integrator in the module `SciPy`.\n",
        "\n",
        "The equation of motion for a classical harmonic oscillator is given\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=0\n",
        "\\end{equation}\n",
        "\n",
        "This is a second order differential equation which requires for its solution two initial conditions. The first initial condition is the initial elongation $x(t=0)=x_{0}$ and the second the initial velocity $\\dot{x}(t=0)=v_{0}$.\n",
        ":::\n",
        "\n",
        "## Implicit Solution\n",
        "\n",
        "Lets start with the matrix appraoch we have just learned about. Using the matrix version, we can transform the above equation into a system of coupled equations, which we can solve with some standard methods available from e.g. the `SciPy` module.\n",
        "\n",
        "### Define Matrices\n",
        "\n",
        "Our matrix will consist of two parts. The first containing the second derivative and the second just the elongation. Suppose we want to calculate the position $x(t)$ at 6 instances in time $t_{i}$\n",
        "then the matrix version of the second derivative reads as\n",
        "\n",
        "($x_{1}=x(t_{1}), \\ldots$).\n",
        "\n",
        "$T=\\frac{d^2x}{dt^2}=\\frac{1}{\\delta t^2}\n",
        "\\begin{bmatrix}\n",
        "-2 & 1  & 0 & 0 & 0 & 0\\\\\n",
        " 1 & -2 & 1 & 0 & 0 & 0\\\\\n",
        " 0 & 1  & -2 & 1 & 0 & 0\\\\\n",
        " 0 & 0  & 1  & -2 & 1 & 0\\\\\n",
        " 0 & 0  & 0  &  1 & -2 & 1\\\\\n",
        " 0 & 0  & 0  &  0 &  1 & -2\\\\\n",
        "\\end{bmatrix}\n",
        "\\begin{bmatrix}\n",
        "x_{1}\\\\\n",
        "x_{2}\\\\\n",
        "x_{3}\\\\\n",
        "x_{4}\\\\\n",
        "x_{5}\\\\\n",
        "x_{6}\n",
        "\\end{bmatrix}$\n",
        "\n",
        "The second term in the equation of motion is a multiplication of the elongation $x(t_{i})$ by $\\omega^{2}$ and can be written as\n",
        "\n",
        "\n",
        "$V=\\omega^2 x=\\begin{bmatrix}\n",
        "\\omega^2  & 0  & 0 & 0 & 0 & 0\\\\\n",
        " 0 & \\omega^2  & 0 & 0 & 0 & 0\\\\\n",
        " 0 & 0  & \\omega^2  & 0 & 0 & 0\\\\\n",
        " 0 & 0  & 0  & \\omega^2  & 0 & 0\\\\\n",
        " 0 & 0  & 0  &  0 & \\omega^2  & 0\\\\\n",
        " 0 & 0  & 0  &  0 &  0 & \\omega^2 \\\\\n",
        "\\end{bmatrix}\n",
        "\\begin{bmatrix}\n",
        "x_{1}\\\\\n",
        "x_{2}\\\\\n",
        "x_{3}\\\\\n",
        "x_{4}\\\\\n",
        "x_{5}\\\\\n",
        "x_{6}\n",
        "\\end{bmatrix}$\n",
        "\n",
        "The left hand side of the would threfore contain a sum of the two matrices $M=T+V$ multiplied by the vector $x$.\n",
        "We have therfore almost all things together to solve this differential equation with the help of an implicit scheme. What we have ignored so far are the initial conditions.\n",
        "\n",
        "\n",
        "### Use Initial Conditions\n",
        "\n",
        "The matrix given for the second detivative actually implies already some initial (bounary) conditions. You probably noticed that the matrix contains incomplete coefficients for the second derivative in the first and last line. The first line contains $(-2,1)$, but the second derivative should contain $(1,-2,1)$. This $(-2,1)$ thus always includes the boundary condition that $x_{0}=0$. To include our own initial/boundary conditions, we have to construct the matrix for the second derivative slightly differently and modify the differential equation to\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=b\n",
        "\\end{equation}\n",
        "\n",
        "where the vector b takes care of the initial conditions.\n",
        "\n",
        "If we have $N$ positions in time at which we calculate the elongation $x$, we have a $N\\times N$ matrix of for the second derivatives. The lower $N-2$ lines will contain the the coefficients for the second derivative $(1,-2,1)$. The first two lines supply the initial/boundary conditions.\n",
        "\n",
        "The initial condition for the elongation $x(t=0)=x_{0}$ is obtained when the first element of the first line is a **1**.\n",
        "The matrix multiplication $M\\, x=b$ for yields thus in the first line $x_{1}=b_{1}$ and we set $b_{1}=x_{0}$. The second line shall give the initial velocity. So the matrix entries of the second line contain a first derivative $(-1,1)$. The matrix multiplication thus yields $x_{2}-x_{1}=b_{2}$. We can therefore need to set $b_{2}=v_{0}\\delta t$. All of the other entries of $b$ shall be set to zero according to the differential equation of the harmonic oscillator.\n",
        "\n",
        "Our final problem $M\\, x=b$ will thus have the following shape\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{bmatrix}\n",
        "1 & 0  & 0 & 0 & 0 & 0\\\\\n",
        "-1 & 1 & 0 & 0 & 0 & 0\\\\\n",
        "1 & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0 & 0\\\\\n",
        "0 & 1  & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0\\\\\n",
        "0 & 0  & 1  &  -2+\\omega^2*\\delta t^2 & 1 & 0\\\\\n",
        "0 & 0  & 0  &  1 &  -2+\\omega^2*\\delta t^2 & 1\\\\\n",
        "\\end{bmatrix}\n",
        "\\begin{bmatrix}\n",
        "x_{1}\\\\\n",
        "x_{2}\\\\\n",
        "x_{3}\\\\\n",
        "x_{4}\\\\\n",
        "x_{5}\\\\\n",
        "x_{6}\n",
        "\\end{bmatrix}=\n",
        "\\begin{bmatrix}\n",
        "x_{0}\\\\\n",
        "v_{0}\\delta t\\\\\n",
        "0\\\\\n",
        "0\\\\\n",
        "0\\\\\n",
        "0\n",
        "\\end{bmatrix}\n",
        "\\end{equation}\n",
        "\n",
        "### Solution\n",
        "\n",
        "This is the final system of coupled equations which we can supply to any matrix solver. We will use a solver from the `scipy.linalg` module. Lets have a look at the details below.\n",
        "\n",
        "```python\n",
        "N=10\n",
        "\n",
        "(diags([-2., 1., 1.], [-1,-2, 0],\n",
        "    shape=(N, N))+diags([1], [-1], shape=(N, N))* omega**2*dt**2)\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "from scipy.sparse import diags\n",
        "\n",
        "k = 15.5 # spring constant\n",
        "m = 0.2 # mass\n",
        "omega=np.sqrt(k/m) # frequency of the oscillator\n",
        "\n",
        "L = np.pi # time period over which we solve the ODE\n",
        "N = 500 # number of data points\n",
        "t = np.linspace(0, L, N) # time axis\n",
        "\n",
        "b = np.zeros(N) # initial conditions vector\n",
        "b[0]=1 # initial elongation\n",
        "b[1]=0 # initial velocity\n",
        "\n",
        "x = np.zeros(N) # solution vector\n",
        "dt = t[1] - t[0] # time intervall of each step\n",
        "\n",
        "# construct the matrix\n",
        "T= diags([-2., 1., 1.], [-1,-2, 0], shape=(N, N)).todense()\n",
        "V= diags([1], [-1], shape=(N, N)).todense()\n",
        "M= T/dt**2 + V*omega**2\n",
        "\n",
        "M[0,0]=1 # initial condition for amplitude, x1=1\n",
        "M[1,0]=-1 # initial condition for velocity, dx/dt=0\n",
        "M[1,1]=1\n",
        "\n",
        "# initial condition vector\n",
        "b=b.transpose()\n",
        "\n",
        "x= np.linalg.solve(M, b) # this is the solution\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "#| fig-align: center\n",
        "plt.figure(figsize=get_size(8,6))\n",
        "plt.plot(t,x)\n",
        "plt.xlabel('time t')\n",
        "plt.ylabel('elongation x(t)')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Explicit Solution - Numerical Integration\n",
        "\n",
        "Before implementing explicit numerical schemes, let's develop a standardized approach for solving ODEs. This framework will allow us to solve different problems using various methods with minimal code modification.\n",
        "\n",
        "Let's examine the free fall problem as an example:\n",
        "\n",
        "\\begin{equation}\n",
        "\\ddot{x}= -g\n",
        "\\end{equation}\n",
        "\n",
        "This second-order equation can be transformed into a system of two first-order equations:\n",
        "\n",
        "\\begin{eqnarray}\n",
        "\\dot{x} &= v \\\\\n",
        "\\dot{v} &= -g\n",
        "\\end{eqnarray}\n",
        "\n",
        "Using the Euler method, these equations become:\n",
        "\n",
        "\\begin{eqnarray}\n",
        "x_{i+1} &= x_i + v_i \\Delta t \\\\\n",
        "v_{i+1} &= v_i - g\\Delta t\n",
        "\\end{eqnarray}\n",
        "\n",
        "Note: The original equations had $\\dot{x}$ and $\\dot{v}$ in the right-hand side, which should be replaced with their actual values ($v$ and $-g$ respectively).\n",
        "\n",
        "These equations can be written more compactly in vector form:\n",
        "\n",
        "\\begin{equation}\n",
        "\\vec{y}_{i+1} = \\vec{y}_i + \\dot{\\vec{y}}_i \\Delta t\n",
        "\\end{equation}\n",
        "\n",
        "where\n",
        "\n",
        "\\begin{equation}\n",
        "\\vec{y}=\n",
        "\\begin{bmatrix}\n",
        "x \\\\\n",
        "v\n",
        "\\end{bmatrix}\n",
        "\\end{equation}\n",
        "\n",
        "and\n",
        "\n",
        "\\begin{equation}\n",
        "\\dot{\\vec{y}}=\n",
        "\\begin{bmatrix}\n",
        "v \\\\\n",
        "-g\n",
        "\\end{bmatrix}\n",
        "\\end{equation}\n",
        "\n",
        "This vector formulation allows us to separate:\n",
        "1. Problem definition (specifying $\\dot{\\vec{y}}$ as a function of $\\vec{y}$ and $t$)\n",
        "2. Solution method (implementing the numerical integration scheme)\n",
        "\n",
        "We'll explore three numerical methods:\n",
        "\n",
        "- **Euler Method**: First-order accurate\n",
        "- **Euler-Cromer Method**: Modified Euler method, better for oscillatory systems\n",
        "- **Midpoint Method**: Second-order accurate\n",
        "\n",
        "More sophisticated methods like the Runge-Kutta family offer higher accuracy but are not covered here.\n",
        "\n",
        "\n",
        "### Euler Method\n",
        "\n",
        "The **Euler method** is derived from the Taylor expansion of the solution $\\vec{y}(t)$ around the current time $t$:\n",
        "\n",
        "\\begin{equation}\n",
        "\\vec{y}(t+\\Delta t)=\\vec{y}(t)+\\dot{\\vec{y}}(t)\\Delta t+\\frac{1}{2}\\ddot{\\vec{y}}(t)\\Delta t^{2}+ \\mathcal{O}(\\Delta t^3)\n",
        "\\end{equation}\n",
        "\n",
        "The Euler method approximates this by truncating after the first-order term:\n",
        "\n",
        "\\begin{equation}\n",
        "\\vec{y}(t+\\Delta t) \\approx \\vec{y}(t) + \\dot{\\vec{y}}(t) \\Delta t\n",
        "\\end{equation}\n",
        "\n",
        "For our free fall example, this becomes:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{bmatrix} x_{i+1} \\\\ v_{i+1} \\end{bmatrix} =\n",
        "\\begin{bmatrix} x_i \\\\ v_i \\end{bmatrix} +\n",
        "\\begin{bmatrix} v_i \\\\ -g \\end{bmatrix} \\Delta t\n",
        "\\end{equation}\n",
        "\n",
        "Error Analysis:\n",
        "The method has two distinct types of errors. The local truncation error, which represents the error made in a single step, is of order $\\mathcal{O}(\\Delta t^2)$. This corresponds to the first term omitted in the Taylor expansion. The global truncation error, which accumulates over the entire integration interval $[0,\\tau]$, is of order $\\mathcal{O}(\\Delta t)$. This can be understood by considering that we take $N = \\tau/\\Delta t$ steps, each contributing an error proportional to $\\Delta t^2$. The total error thus scales as $N \\cdot \\Delta t^2 = \\tau \\Delta t$.\n",
        "\n",
        "Limitations and Extensions:\n",
        "The method is directly applicable only to first-order systems of the form $\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)$. However, this is not a fundamental limitation as higher-order equations can be converted to systems of first-order equations. For example, a second-order equation $\\ddot{x} = f(x,\\dot{x},t)$ can be transformed into a system of two first-order equations by introducing the velocity as an additional variable. The resulting system becomes:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} =\n",
        "\\begin{bmatrix} v \\\\ f(x,v,t) \\end{bmatrix}\n",
        "\\end{equation}\n",
        "\n",
        "This transformation allows us to apply the method to a wider class of problems while maintaining its fundamental characteristics.\n",
        "\n",
        "### Euler-Cromer Method\n",
        "\n",
        "The **Euler-Cromer method** (also known as the semi-implicit Euler method) modifies the basic Euler method by using the updated velocity when calculating the position. For a system described by position and velocity:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{aligned}\n",
        "\\dot{x} &= v \\\\\n",
        "\\dot{v} &= f(x,v,t)\n",
        "\\end{aligned}\n",
        "\\end{equation}\n",
        "\n",
        "The integration steps are:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{aligned}\n",
        "v_{i+1} &= v_i + f(x_i,v_i,t_i)\\Delta t \\\\\n",
        "x_{i+1} &= x_i + v_{i+1}\\Delta t\n",
        "\\end{aligned}\n",
        "\\end{equation}\n",
        "\n",
        "For our free fall example:\n",
        "\\begin{equation}\n",
        "\\begin{aligned}\n",
        "v_{i+1} &= v_i - g\\Delta t \\\\\n",
        "x_{i+1} &= x_i + v_{i+1}\\Delta t\n",
        "\\end{aligned}\n",
        "\\end{equation}\n",
        "\n",
        "Energy Behavior:\n",
        "The method shows improved energy conservation for oscillatory systems compared to the standard Euler method. While the Euler method typically increases energy over time, the Euler-Cromer method exhibits small energy oscillations around the correct value.\n",
        "\n",
        "Error Analysis:\n",
        "The method maintains a local truncation error of $\\mathcal{O}(\\Delta t^2)$ and a global truncation error of $\\mathcal{O}(\\Delta t)$. Despite having the same order of accuracy as the Euler method, it provides more stable solutions for oscillatory systems.\n",
        "\n",
        "Advantages:\n",
        "The Euler-Cromer method represents a simple modification of the Euler method that achieves better stability for oscillatory systems without requiring additional function evaluations.\n",
        "\n",
        "Limitations:\n",
        "The method remains first-order accurate globally and is not symmetric in time. While it performs well for certain types of problems, particularly oscillatory systems, it may not be suitable for all differential equations.\n",
        "\n",
        "Comparison with Euler Method:\n",
        "\n",
        "```python\n",
        "# Euler Method\n",
        "v[i+1] = v[i] + f(x[i],v[i],t[i])*dt\n",
        "x[i+1] = x[i] + v[i]*dt       # Uses old velocity\n",
        "\n",
        "# Euler-Cromer Method\n",
        "v[i+1] = v[i] + f(x[i],v[i],t[i])*dt\n",
        "x[i+1] = x[i] + v[i+1]*dt     # Uses new velocity\n",
        "```\n",
        "\n",
        "\n",
        "### Midpoint Method\n",
        "\n",
        "The **Midpoint Method** (also known as the second-order Runge-Kutta method) improves upon both the Euler and Euler-Cromer methods by using the average of the derivatives at the current point and an estimated midpoint.\n",
        "\n",
        "For a system of first-order differential equations:\n",
        "\n",
        "\\begin{equation}\n",
        "\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)\n",
        "\\end{equation}\n",
        "\n",
        "The algorithm proceeds in two steps:\n",
        "\n",
        "1. Calculate an intermediate point using an Euler step to the midpoint:\n",
        "\\begin{equation}\n",
        "\\vec{k}_1 = \\vec{f}(\\vec{y}_i,t_i)\n",
        "\\end{equation}\n",
        "\\begin{equation}\n",
        "\\vec{y}_{i+1/2} = \\vec{y}_i + \\frac{\\Delta t}{2}\\vec{k}_1\n",
        "\\end{equation}\n",
        "\n",
        "2. Use the derivative at this midpoint for the full step:\n",
        "\\begin{equation}\n",
        "\\vec{k}_2 = \\vec{f}(\\vec{y}_{i+1/2},t_i+\\Delta t/2)\n",
        "\\end{equation}\n",
        "\\begin{equation}\n",
        "\\vec{y}_{i+1} = \\vec{y}_i + \\Delta t\\vec{k}_2\n",
        "\\end{equation}\n",
        "\n",
        "For our free fall example, this becomes:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{aligned}\n",
        "v_{i+1/2} &= v_i - \\frac{g\\Delta t}{2} \\\\\n",
        "x_{i+1/2} &= x_i + v_i\\frac{\\Delta t}{2} \\\\\n",
        "v_{i+1} &= v_i - g\\Delta t \\\\\n",
        "x_{i+1} &= x_i + v_{i+1/2}\\Delta t\n",
        "\\end{aligned}\n",
        "\\end{equation}\n",
        "\n",
        "Error Analysis:\n",
        "The method achieves higher accuracy than both Euler and Euler-Cromer methods with:\n",
        "\n",
        "- Local truncation error: $\\mathcal{O}(\\Delta t^3)$\n",
        "- Global truncation error: $\\mathcal{O}(\\Delta t^2)$\n",
        "\n",
        "Implementation:\n",
        "```python\n",
        "def midpoint_step(y, t, dt, f):\n",
        "    # Calculate k1\n",
        "    k1 = f(y, t)\n",
        "\n",
        "    # Calculate midpoint\n",
        "    y_mid = y + 0.5 * dt * k1\n",
        "\n",
        "    # Calculate k2 at midpoint\n",
        "    k2 = f(y_mid, t + 0.5*dt)\n",
        "\n",
        "    # Full step using midpoint derivative\n",
        "    return y + dt * k2\n",
        "```"
      ],
      "id": "96424306"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: true\n",
        "#| fig-align: center\n",
        "## high precision\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "def get_size(w, h):\n",
        "    \"\"\"Convert cm to inches for figure size\"\"\"\n",
        "    return (w/2.54, h/2.54)\n",
        "\n",
        "def set_plot_style():\n",
        "    \"\"\"Set default plotting parameters\"\"\"\n",
        "    plt.rcParams.update({\n",
        "        'font.size': 10,\n",
        "        'lines.linewidth': 1,\n",
        "        'lines.markersize': 5,\n",
        "        'axes.labelsize': 10,\n",
        "        'xtick.labelsize': 10,\n",
        "        'ytick.labelsize': 10,\n",
        "        'xtick.top': True,\n",
        "        'xtick.direction': 'in',\n",
        "        'ytick.right': True,\n",
        "        'ytick.direction': 'in',\n",
        "    })\n",
        "\n",
        "def euler_method(t, x0, v0, g):\n",
        "    \"\"\"Implement Euler method\"\"\"\n",
        "    v = np.zeros_like(t)\n",
        "    x = np.zeros_like(t)\n",
        "    v[0], x[0] = v0, x0\n",
        "    dt = t[1] - t[0]\n",
        "\n",
        "    for i in range(len(t)-1):\n",
        "        v[i+1] = v[i] + g*dt\n",
        "        x[i+1] = x[i] + v[i]*dt\n",
        "\n",
        "    return x, v\n",
        "\n",
        "def euler_cromer_method(t, x0, v0, g):\n",
        "    \"\"\"Implement Euler-Cromer method\"\"\"\n",
        "    v = np.zeros_like(t)\n",
        "    x = np.zeros_like(t)\n",
        "    v[0], x[0] = v0, x0\n",
        "    dt = t[1] - t[0]\n",
        "\n",
        "    for i in range(len(t)-1):\n",
        "        v[i+1] = v[i] + g*dt\n",
        "        x[i+1] = x[i] + v[i+1]*dt\n",
        "\n",
        "    return x, v\n",
        "\n",
        "def midpoint_method(t, x0, v0, g):\n",
        "    \"\"\"Implement Midpoint method\"\"\"\n",
        "    v = np.zeros_like(t)\n",
        "    x = np.zeros_like(t)\n",
        "    v[0], x[0] = v0, x0\n",
        "    dt = t[1] - t[0]\n",
        "\n",
        "    for i in range(len(t)-1):\n",
        "        v[i+1] = v[i] + g*dt\n",
        "        x[i+1] = x[i] + (v[i+1] + v[i])*dt/2\n",
        "\n",
        "    return x, v\n",
        "\n",
        "def analytical_solution(t, x0, v0, g):\n",
        "    \"\"\"Calculate analytical solution\"\"\"\n",
        "    return x0 + v0*t + 0.5*g*t**2\n",
        "\n",
        "def compare_methods(T=2.0, N_coarse=5, N_fine=1000, x0=0, v0=10, g=-9.81):\n",
        "    \"\"\"Compare all methods with analytical solution\"\"\"\n",
        "    # Fine grid for analytical solution\n",
        "    t_fine = np.linspace(0, T, N_fine)\n",
        "    x_analytical = analytical_solution(t_fine, x0, v0, g)\n",
        "\n",
        "    # Coarse grid for numerical methods\n",
        "    t_coarse = np.linspace(0, T, N_coarse)\n",
        "\n",
        "    # Calculate solutions\n",
        "    x_euler, _ = euler_method(t_coarse, x0, v0, g)\n",
        "    x_euler_cromer, _ = euler_cromer_method(t_coarse, x0, v0, g)\n",
        "    x_midpoint, _ = midpoint_method(t_coarse, x0, v0, g)\n",
        "\n",
        "    # Plotting\n",
        "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(20, 10))\n",
        "\n",
        "    # Plot full trajectories\n",
        "    ax1.plot(t_fine, x_analytical, 'k-', linewidth=0.5, label='Analytical')\n",
        "    ax1.plot(t_coarse, x_euler, 'bo-', linewidth=0.5, label='Euler')\n",
        "    ax1.plot(t_coarse, x_euler_cromer, 'ro-', linewidth=0.5, label='Euler-Cromer')\n",
        "    ax1.plot(t_coarse, x_midpoint, 'go-', linewidth=0.5, label='Midpoint')\n",
        "\n",
        "    # Add grid lines\n",
        "    for t in t_coarse:\n",
        "        ax1.axvline(x=t, color='black', linewidth=0.2)\n",
        "\n",
        "    # Add annotations\n",
        "    for i, (t, x) in enumerate(zip(t_coarse, x_euler)):\n",
        "        ax1.annotate(f'$x_{i}$', xy=(t, x), xytext=(5, 5),\n",
        "                    textcoords='offset points', fontsize=15)\n",
        "\n",
        "    ax1.set_xlabel('t [s]', fontsize=16)\n",
        "    ax1.set_ylabel('x [m]', fontsize=16)\n",
        "    ax1.legend(loc='lower left')\n",
        "    ax1.grid(True)\n",
        "\n",
        "    # Plot errors\n",
        "    x_analytical_coarse = analytical_solution(t_coarse, x0, v0, g)\n",
        "    errors_euler = np.abs(x_euler - x_analytical_coarse)\n",
        "    errors_euler_cromer = np.abs(x_euler_cromer - x_analytical_coarse)\n",
        "    errors_midpoint = np.abs(x_midpoint - x_analytical_coarse)\n",
        "\n",
        "    ax2.plot(t_coarse, errors_euler, 'bo-', label='Euler Error')\n",
        "    ax2.plot(t_coarse, errors_euler_cromer, 'ro-', label='Euler-Cromer Error')\n",
        "    ax2.semilogy(t_coarse, errors_midpoint, 'gx-', label='Midpoint Error')\n",
        "    ax2.set_xlabel('t [s]', fontsize=16)\n",
        "    ax2.set_ylabel('absolute error', fontsize=16)\n",
        "    ax2.legend()\n",
        "    ax2.grid(True)\n",
        "\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "# Set plot style and run comparison\n",
        "set_plot_style()\n",
        "compare_methods()"
      ],
      "id": "58e556e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Putting it all together\n",
        "\n",
        "Now we can implement our numerical solution by combining our understanding of both the physical system and numerical methods. This implementation consists of two main parts: defining the differential equation and solving it numerically.\n",
        "\n",
        "#### The Definition of the Problem\n",
        "\n",
        "For the simple harmonic oscillator, we start with the second-order differential equation:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{d^2x}{dt^2} + \\omega^2x = 0\n",
        "\\end{equation}\n",
        "\n",
        "To solve this numerically, we convert it to a system of first-order equations using our state vector $\\vec{y} = [x, v]^T$:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{d}{dt}\\begin{bmatrix} x \\\\ v \\end{bmatrix} =\n",
        "\\begin{bmatrix} v \\\\ -\\omega^2x \\end{bmatrix}\n",
        "\\end{equation}\n",
        "\n",
        "This is implemented as:\n",
        "~~~\n",
        "def SHO(state, time):\n",
        "    \"\"\"\n",
        "    Define the harmonic oscillator system.\n",
        "    state[0] : position x\n",
        "    state[1] : velocity v\n",
        "    returns  : [dx/dt, dv/dt]\n",
        "    \"\"\"\n",
        "    g0 = state[1]         # dx/dt = v\n",
        "    g1 = -k/m*state[0]    # dv/dt = -ω²x\n",
        "    return np.array([g0, g1])\n",
        "~~~\n",
        "\n",
        "This function defines our physical system by returning the derivatives of our state variables at any given point.\n",
        "\n",
        "#### Solving the Problem\n",
        "\n",
        "With our system defined, we can implement the numerical solution using Euler's method. The basic algorithm takes the current state and advances it by one time step:\n",
        "\n",
        "~~~\n",
        "def euler(y, t, dt, derivs):\n",
        "    \"\"\"\n",
        "    Perform one step of the Euler method.\n",
        "    y      : current state [x, v]\n",
        "    t      : current time\n",
        "    dt     : time step\n",
        "    derivs : function returning derivatives\n",
        "    \"\"\"\n",
        "    y_next = y + derivs(y, t) * dt\n",
        "    return y_next\n",
        "~~~\n",
        "\n",
        "This simple structure allows us to solve different physical problems by just changing the derivative function. For example, we can solve the free fall problem with initial conditions $x_0=0$ and $v_0=10$, or the harmonic oscillator with specified spring constant $k$ and mass $m$.\n",
        "\n",
        "The key advantage of this structure lies in its flexibility. We can change the physical system by providing a different derivative function, implement various numerical methods by modifying the integration step, and explore the system behavior by adjusting parameters and initial conditions. This modular approach allows us to study a wide range of physical systems using the same basic numerical framework.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# Parameters\n",
        "N = 2000  # number of steps\n",
        "tau = 4*np.pi  # time period\n",
        "xo = 1.0  # initial position\n",
        "vo = 0.0  # initial velocity\n",
        "\n",
        "k = 3.5\n",
        "m = 0.2\n",
        "gravity = 9.8\n",
        "\n",
        "dt = tau/float(N-1)\n",
        "time = np.linspace(0, tau, N)\n",
        "\n",
        "y = np.zeros([N, 2])\n",
        "y[0, 0] = xo\n",
        "y[0, 1] = vo\n",
        "\n",
        "\n",
        "##  defining the problem\n",
        "def free_fall(state , time):\n",
        "    g0 = state[1]\n",
        "    g1 = -gravity\n",
        "    return(np.array([g0, g1]))\n",
        "\n",
        "\n",
        "def SHO(y, t, b=0, k=3.5):\n",
        "    x, v = y\n",
        "    dydt = [v, -b*v - k*x]\n",
        "    return np.array(dydt)\n",
        "\n",
        "\n",
        "def MMM(state, time):\n",
        "    g0 = state[1]-1.1*state[1]\n",
        "    g1 = -k/m * state[0]-12\n",
        "    return(np.array([g0, g1]))\n",
        "\n",
        "##  solving the problem with euler\n",
        "def euler(y, t, dt, derivs):\n",
        "    y_next = y + derivs(y,t)* dt\n",
        "    return(y_next)\n",
        "\n",
        "def runge_kutta2(y, time, dt, derivs):\n",
        "    k0 = dt * derivs(y, time)\n",
        "    k1 = dt * derivs(y + k0, time + dt)\n",
        "    y_next = y + 0.5 * (k0 + k1)\n",
        "    return y_next\n",
        "\n",
        "# Solve the differential equation\n",
        "for j in range(N-1):\n",
        "    y[j+1] = euler(y[j], time[j], dt, SHO)\n",
        "\n",
        "# Plot results\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\n",
        "\n",
        "ax1.plot(time, y[:, 0])\n",
        "ax1.set_title(\"Position\")\n",
        "ax1.set_xlabel('time [s]', fontsize=16)\n",
        "ax1.set_ylabel('position x [m]', fontsize=16)\n",
        "ax1.tick_params(labelsize=14)\n",
        "\n",
        "ax2.plot(time, y[:, 1])\n",
        "ax2.set_title(\"Velocity\")\n",
        "ax2.set_xlabel('time [s]', fontsize=16)\n",
        "ax2.set_ylabel('velocity v [m/s]', fontsize=16)\n",
        "ax2.tick_params(labelsize=14)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Solving the Harmonic Oscillator with SciPy {#sec-solving-ODE}\n",
        "\n",
        "Having explored basic numerical integration methods, we can now utilize more sophisticated tools available in SciPy. The `scipy.integrate.odeint()` function provides a robust and accurate integration method with several advantages over our simple implementations.\n",
        "\n",
        "To use SciPy's integrator:\n",
        "```python\n",
        "from scipy.integrate import odeint\n",
        "```\n",
        "\n",
        "The basic syntax is:\n",
        "```python\n",
        "solution = odeint(derivative_function, initial_conditions, time_points)\n",
        "```\n",
        "\n",
        "where:\n",
        "\n",
        "- `derivative_function` defines the system (like our `SHO` function)\n",
        "- `initial_conditions` is a vector containing $[x_0, v_0]$\n",
        "- `time_points` is an array of times at which to compute the solution\n",
        "\n",
        "The `odeint` function offers several significant advantages over our simple implementations. It features adaptive step size control, which automatically adjusts the integration step size based on the local error. The function performs continuous error estimation and correction to maintain accuracy throughout the integration. It also provides various integration methods that can be selected based on the problem's requirements. The function is capable of handling stiff equations, which are particularly challenging for simpler methods, and generally provides better numerical stability across a wide range of problems.\n",
        "\n",
        "For example, to solve the harmonic oscillator:\n",
        "```python\n",
        "def SHO(state, t, k=1.0, m=1.0):\n",
        "    x, v = state\n",
        "    return [v, -k/m * x]\n",
        "\n",
        "# Initial conditions\n",
        "y0 = [1.0, 0.0]  # x₀ = 1, v₀ = 0\n",
        "t = np.linspace(0, 10, 1000)\n",
        "\n",
        "# Solve the system\n",
        "solution = odeint(SHO, y0, t)\n",
        "```\n",
        "\n",
        "The solution array contains:\n",
        "\n",
        "- `solution[:, 0]`: position values\n",
        "- `solution[:, 1]`: velocity values\n",
        "\n",
        "Having understood the fundamentals of numerical integration through our implementations of Euler and other methods, we can now confidently use this more sophisticated tool for solving differential equations more accurately and efficiently.\n",
        "\n",
        "### Setup\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "from scipy.integrate import odeint\n",
        "\n",
        "N = 1000  # number of steps\n",
        "xo = 1.0 # initial position\n",
        "vo = 0.0 # initial velocity\n",
        "tau = 4*np.pi # time period\n",
        "\n",
        "k = 3.5\n",
        "m = 0.2\n",
        "gravity = 9.8\n",
        "\n",
        "time = np.linspace(0, tau, N)\n",
        "\n",
        "y = np.zeros(2)\n",
        "y[0] = xo\n",
        "y[1] = vo\n",
        "\n",
        "```\n",
        "\n",
        "### Definition\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "##  defining the problem\n",
        "def SHO(state, time):\n",
        "    g0 = state[1]\n",
        "    g1 = -k/m * state [0]\n",
        "    return(np.array([g0, g1]))\n",
        "```\n",
        "\n",
        "### Solution\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "answer = odeint( SHO, y , time )\n",
        "```\n",
        "\n",
        "### Plotting\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "fig=plt.figure(1, figsize = (10,5) )\n",
        "plt.subplot(1, 2, 1)\n",
        "plt.plot(time, answer[:,0])\n",
        "plt.ylabel(\"position , velocity\")\n",
        "plt.xlabel('time [s]', fontsize=16)\n",
        "plt.ylabel('position x [m]',fontsize=16)\n",
        "plt.tick_params(labelsize=14)\n",
        "\n",
        "plt.subplot(1, 2, 2)\n",
        "plt.plot(time, answer[:,1])\n",
        "plt.xlabel('time [s]', fontsize=16)\n",
        "plt.ylabel('velocity v [m/s]',fontsize=16)\n",
        "plt.tick_params(labelsize=14)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Damped Driven Pendulum in SciPy\n",
        "\n",
        "Write a `derivs` function for a damped driven pendulum:\n",
        "\n",
        "\\begin{equation}\n",
        "\\ddot{\\theta}=-\\frac{g}{L}\\sin(\\theta)-b \\dot{\\theta}+\\beta\\cos(\\omega t)\n",
        "\\end{equation}\n",
        "\n",
        "Use this *derivs* function with the *SciPy* solver and plot the result for different parameters. Vary the damping parameter $b$. Observe the contributions of the homogeneous and the particular solution. Plot the amplitude of the stationary solution as a function of frequency!\n",
        "\n",
        "### Setup\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "N = 10000  # number of steps\n",
        "theta_o = 1.0 # initial position\n",
        "vo = -0.0 # initial velocity\n",
        "tau = 100.0 # time period\n",
        "\n",
        "length=10.0\n",
        "b=0.2\n",
        "beta=np.pi/2\n",
        "gravity = 9.8\n",
        "omega=np.sqrt(gravity/length)\n",
        "\n",
        "\n",
        "time = np.linspace(0, tau, N)\n",
        "\n",
        "y = np.zeros (2)\n",
        "y[0] = theta_o\n",
        "y[1] = vo\n",
        "```\n",
        "\n",
        "### Definition\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "def pendulum_def(state , time):\n",
        "    g0 = state[1]\n",
        "    g1 = -gravity/length * np.sin(state[0]) - b*state[1] + beta*np.cos(omega * time)\n",
        "    return(np.array([g0, g1]) )\n",
        "```\n",
        "\n",
        "### Solution\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "answer = odeint( pendulum_def, y , time )\n",
        "```\n",
        "\n",
        "### Plotting\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "fig=plt.figure(1, figsize = (8,6) )\n",
        "plt.plot(time,beta*np.cos(omega * time),'r--',alpha=0.3)\n",
        "plt.plot(time, answer[:,0])\n",
        "plt.xlabel('time [s]', fontsize=16)\n",
        "plt.ylabel('angular velocity',fontsize=16)\n",
        "plt.tick_params(labelsize=14)\n",
        "plt.show()\n",
        "```"
      ],
      "id": "46c44a04"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}