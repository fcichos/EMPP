{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Numerical Integration\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "This lecture covers numerical integration methods, which are essential for computing definite integrals of functions. We'll explore three different methods with increasing accuracy: the Box method, Trapezoid method, and Simpson's method.\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.optimize import curve_fit\n",
        "\n",
        "# Set default plotting parameters\n",
        "plt.rcParams.update({\n",
        "    'font.size': 12,\n",
        "    'lines.linewidth': 1,\n",
        "    'lines.markersize': 5,\n",
        "    'axes.labelsize': 11,\n",
        "    'xtick.labelsize': 10,\n",
        "    'ytick.labelsize': 10,\n",
        "    'xtick.top': True,\n",
        "    'xtick.direction': 'in',\n",
        "    'ytick.right': True,\n",
        "    'ytick.direction': 'in',\n",
        "})\n",
        "\n",
        "def get_size(w, h):\n",
        "    return (w/2.54, h/2.54)\n",
        "```\n",
        "\n",
        "## Box Method (Rectangle Method)\n",
        "\n",
        "![Box Method Illustration](img/box.png)\n",
        "\n",
        "The Box method is the simplest approach for numerical integration. It approximates the function in each interval $\\Delta x$ with a constant value taken at the left endpoint of the interval.\n",
        "\n",
        "\\begin{equation}\n",
        "\\int_{a}^{b} f(x) dx \\approx \\sum_{i=1}^{N} f(x_{i}) \\Delta x\n",
        "\\end{equation}\n",
        "\n",
        "```{pyodide}\n",
        "def f(x):\n",
        "    \"\"\"Example function to integrate: f(x) = x\"\"\"\n",
        "    return x\n",
        "\n",
        "def int_box(f, a, b, N):\n",
        "\n",
        "    if N < 2:\n",
        "        raise ValueError(\"N must be at least 2\")\n",
        "    x = np.linspace(a, b, N)\n",
        "    y = f(x)\n",
        "    return np.sum((x[1]-x[0])*y)\n",
        "\n",
        "# Example calculation and convergence demonstration\n",
        "N_values = np.arange(10, 10000, 100)\n",
        "box_results = [int_box(f, 0, 1, N) for N in N_values]\n",
        "\n",
        "plt.figure(figsize=get_size(15, 10))\n",
        "plt.plot(N_values, box_results, label='Box Method')\n",
        "plt.xlabel('Number of points (N)')\n",
        "plt.ylabel('Integral value')\n",
        "plt.title('Convergence of Box Method')\n",
        "plt.grid(True)\n",
        "plt.legend()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Trapezoid Method\n",
        "\n",
        "![Trapezoid Method Illustration](img/trapez.png)\n",
        "\n",
        "The Trapezoid method improves upon the Box method by approximating the function with linear segments between points.\n",
        "\n",
        "\\begin{equation}\n",
        "\\int_{a}^{b} f(x) dx \\approx \\sum_{i=1}^{N} \\frac{f(x_i) + f(x_{i-1})}{2} \\Delta x\n",
        "\\end{equation}\n",
        "\n",
        "```{pyodide}\n",
        "def int_trap(f, a, b, N):\n",
        "    if N < 2:\n",
        "        raise ValueError(\"N must be at least 2\")\n",
        "    x = np.linspace(a, b, N)\n",
        "    y = f(x)\n",
        "    return np.sum((y[1:] + y[:-1]) * (x[1]-x[0])/2)\n",
        "```\n",
        "\n",
        "## Simpson's Method\n",
        "\n",
        "![Simpson's Method Illustration](img/simpson.png)\n",
        "\n",
        "Simpson's method provides higher accuracy by approximating the function with parabolic segments.\n",
        "\n",
        "\\begin{equation}\n",
        "\\int_{a}^{b} f(x) dx \\approx \\frac{\\Delta x}{3} \\sum_{i=1}^{(N-1)/2} \\left(f(x_{i-1}) + 4f(x_i) + f(x_{i+1})\\right)\n",
        "\\end{equation}\n",
        "\n",
        "```{pyodide}\n",
        "def int_simp(f, a, b, N):\n",
        "    if N % 2 == 0:\n",
        "        raise ValueError(\"N must be odd for Simpson's method\")\n",
        "    if N < 3:\n",
        "        raise ValueError(\"N must be at least 3\")\n",
        "\n",
        "    x = np.linspace(a, b, N)\n",
        "    y = f(x)\n",
        "    return np.sum((y[0:-2:2] + 4*y[1:-1:2] + y[2::2]) * (x[1]-x[0])/3)\n",
        "```\n",
        "\n",
        "::: {.callout-note collapse=true}\n",
        "## Simpson's Rule for Numerical Integration\n",
        "\n",
        "Simpson's Rule is a method for numerical integration that approximates the definite integral of a function by using quadratic polynomials.\n",
        "\n",
        "\n",
        "1) For an integral $\\int_a^b f(x)dx$, Simpson's Rule fits a quadratic function through three points:\n",
        "\n",
        "   - $f(a)$\n",
        "   - $f(\\frac{a+b}{2})$\n",
        "   - $f(b)$\n",
        "\n",
        "2) Let's define:\n",
        "\n",
        "   - $h = \\frac{b-a}{2}$\n",
        "   - $x_0 = a$\n",
        "   - $x_1 = \\frac{a+b}{2}$\n",
        "   - $x_2 = b$\n",
        "\n",
        "3) The quadratic approximation has the form:\n",
        "   $$P(x) = Ax^2 + Bx + C$$\n",
        "\n",
        "4) This polynomial must satisfy:\n",
        "   $$f(x_0) = Ax_0^2 + Bx_0 + C$$\n",
        "   $$f(x_1) = Ax_1^2 + Bx_1 + C$$\n",
        "   $$f(x_2) = Ax_2^2 + Bx_2 + C$$\n",
        "\n",
        "5) Using Lagrange interpolation:\n",
        "   $$P(x) = f(x_0)L_0(x) + f(x_1)L_1(x) + f(x_2)L_2(x)$$\n",
        "\n",
        "   where $L_0$, $L_1$, $L_2$ are the Lagrange basis functions.\n",
        "\n",
        "### Final Formula\n",
        "\n",
        "The integration of this polynomial leads to Simpson's Rule:\n",
        "\n",
        "$$\\int_a^b f(x)dx \\approx \\frac{h}{3}[f(a) + 4f(\\frac{a+b}{2}) + f(b)]$$\n",
        "\n",
        "### Error Term\n",
        "\n",
        "The error in Simpson's Rule is proportional to:\n",
        "\n",
        "$$-\\frac{h^5}{90}f^{(4)}(\\xi)$$\n",
        "\n",
        "for some $\\xi \\in [a,b]$\n",
        "\n",
        "### Composite Simpson's Rule\n",
        "\n",
        "For better accuracy, we can divide the interval into $n$ subintervals (where $n$ is even):\n",
        "\n",
        "$$\\int_a^b f(x)dx \\approx \\frac{h}{3}[f(x_0) + 4\\sum_{i=1}^{n/2}f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1}f(x_{2i}) + f(x_n)]$$\n",
        "\n",
        "where $h = \\frac{b-a}{n}$\n",
        "\n",
        "\n",
        "The method is particularly effective for integrating functions that can be well-approximated by quadratic polynomials over small intervals.\n",
        ":::\n",
        "\n",
        "## Comparison of Methods\n",
        "\n",
        "Let's compare the accuracy of all three methods:\n",
        "\n",
        "```{pyodide}\n",
        "def compare_methods(f, a, b, N_range):\n",
        "    \"\"\"Compare the accuracy of all three integration methods.\"\"\"\n",
        "    exact = 0.5  # Exact value of integral of f(x)=x from 0 to 1\n",
        "\n",
        "    errors = {'Box': [], 'Trapezoid': [], 'Simpson': []}\n",
        "    N_values = []\n",
        "\n",
        "    for N in N_range:\n",
        "        if N % 2 == 1:  # Only use odd N for fair comparison\n",
        "            N_values.append(N)\n",
        "            errors['Box'].append(abs(int_box(f, a, b, N) - exact))\n",
        "            errors['Trapezoid'].append(abs(int_trap(f, a, b, N) - exact))\n",
        "            errors['Simpson'].append(abs(int_simp(f, a, b, N) - exact))\n",
        "\n",
        "    plt.figure(figsize=get_size(15, 10))\n",
        "    plt.loglog(N_values, errors['Box'], 'o-', label='Box Method')\n",
        "    plt.loglog(N_values, errors['Trapezoid'], 's-', label='Trapezoid Method')\n",
        "    plt.loglog(N_values, errors['Simpson'], '^-', label='Simpson Method')\n",
        "    plt.xlabel('Number of points (N)')\n",
        "    plt.ylabel('Absolute Error')\n",
        "    plt.title('Convergence Comparison of Integration Methods')\n",
        "    plt.grid(True)\n",
        "    plt.legend()\n",
        "    plt.show()\n",
        "\n",
        "# Compare methods for N from 3 to 99 (odd numbers only)\n",
        "compare_methods(f, 0, 1, range(3, 100, 2))\n",
        "```\n",
        "\n",
        "## Error Analysis\n",
        "\n",
        "The three methods have different convergence rates:\n",
        "\n",
        "- Box Method: Error ∝ $\\Delta x$ (linear convergence)\n",
        "- Trapezoid Method: Error ∝ $\\Delta x^2$ (quadratic convergence)\n",
        "- Simpson's Method: Error ∝ $\\Delta x^4$ (fourth-order convergence)\n",
        "\n",
        "This explains why Simpson's method typically achieves higher accuracy with fewer points. For example, doubling the number of points in Simpson's method reduces the error by a factor of 16"
      ],
      "id": "baed5730"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}