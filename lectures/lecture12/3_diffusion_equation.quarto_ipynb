{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Diffusion equation\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "    fig-align: center\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "\n",
        "So far, we have always looked at ordinary differential equations, i.e. differential equations where the physical quantity we considered was depending only on one variable. In a lot of physical problems, the observable quantities depend on multiple variables like time and space. The differential equations, which govern those problems are partial differential equations. The diffusion equation is one of them. It pops up in various forms in physics, describing also heat conduction and in a slighly modified way this is corresponding to the time dependent Schrödinger equation.\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy import sparse\n",
        "from scipy.sparse import linalg  # for sparse.linalg.spsolve\n",
        "from scipy.integrate import odeint\n",
        "\n",
        "# Set default plotting parameters\n",
        "plt.rcParams.update({\n",
        "    'font.size': 12,\n",
        "    'lines.linewidth': 1,\n",
        "    'lines.markersize': 5,\n",
        "    'axes.labelsize': 11,\n",
        "    'xtick.labelsize': 10,\n",
        "    'ytick.labelsize': 10,\n",
        "    'xtick.top': True,\n",
        "    'xtick.direction': 'in',\n",
        "    'ytick.right': True,\n",
        "    'ytick.direction': 'in',\n",
        "})\n",
        "\n",
        "def get_size(w, h):\n",
        "    return (w/2.54, h/2.54)\n",
        "```\n",
        "\n",
        "## Physical Model\n",
        "\n",
        "You've probably seen how ink spreads in water - this spreading is called diffusion and is the result of the Brownian motion of ink particles in water. We have already simulated the random motion in Lecture 5 and the real-time animation below shows this process, when all particles are starting at the center of the box. The diffusion equation describes how the concentration of particles (the number of particles per unit volume) changes over time and space.\n",
        "\n",
        "While physicists describe this with complex equations, our goal in this course is to learn how to simulate this process using Python. So the main task will be to split the diffusion equation into small pieces that we can calculate with a computer.\n",
        "\n",
        "The basic diffusion equation looks like this:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c({\\bf r},t)}{\\partial t}=D\\Delta c ({\\bf r},t)\n",
        "\\end{equation}\n",
        "\n",
        "Here, $c$ represents the concentration (like how much ink is at each point), $t$ is time, and ${\\bf r}$ is position. $D$ is just a number that tells us how fast the diffusion happens. Its unit is length squared per time.\n",
        "\n",
        "To make this easier to program, we'll look at diffusion in just one direction (like along a line). This gives us:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c(x,t)}{\\partial t}=D\\frac{\\partial^2 c(x,t)}{\\partial x^{2}}\n",
        "\\end{equation}\n",
        "\n",
        "To turn this equation into code, we need to break up space and time into small pieces. We'll use $c^{n}_{i}$ in our program, where ${\\bf n}$ is which time step we're on, and ${\\bf i}$ tells us which point in space we're looking at.\n",
        "\n",
        "***\n",
        "\n",
        "::: {#fig-diffusion-equation fig-align=center}\n",
        "```{ojs}\n",
        "//| echo: false\n",
        "//| fig-align: center\n",
        "width = 600\n",
        "height = 600\n",
        "margin = ({top: 20, right: 30, bottom: 20, left: 40})\n",
        "plotHeight = 100\n",
        "\n",
        "viewof simulation = {\n",
        "  // Create main container\n",
        "  const container = d3.create(\"div\")\n",
        "    .style(\"display\", \"flex\")\n",
        "    .style(\"flex-direction\", \"column\");\n",
        "\n",
        "  // Create SVG for particle simulation\n",
        "  const svg = container.append(\"svg\")\n",
        "    .attr(\"width\", width)\n",
        "    .attr(\"height\", height - plotHeight)\n",
        "    .attr(\"viewBox\", [0, 0, width, height - plotHeight]);\n",
        "\n",
        "  // Create SVG for histogram\n",
        "  const histogramSvg = container.append(\"svg\")\n",
        "    .attr(\"width\", width)\n",
        "    .attr(\"height\", plotHeight)\n",
        "    .attr(\"viewBox\", [0, 0, width, plotHeight]);\n",
        "\n",
        "  const numParticles = 1000;\n",
        "  const D = 0.5; // Diffusion coefficient\n",
        "  const numBins = 80;\n",
        "\n",
        "  // Create particles at the center\n",
        "  const particles = Array.from({length: numParticles}, () => ({\n",
        "    x: width / 2,\n",
        "    y: (height - plotHeight) / 2,\n",
        "    vx: 0,\n",
        "    vy: 0\n",
        "  }));\n",
        "\n",
        "  // Setup scales for histogram\n",
        "  const xScale = d3.scaleLinear()\n",
        "    .domain([0, width])\n",
        "    .range([margin.left, width - margin.right]);\n",
        "\n",
        "  const yScale = d3.scaleLinear()\n",
        "    .domain([0, numParticles/5])\n",
        "    .range([plotHeight - margin.bottom, margin.top]);\n",
        "\n",
        "  // Create histogram generator\n",
        "  const histogram = d3.bin()\n",
        "    .domain(xScale.domain())\n",
        "    .thresholds(xScale.ticks(numBins))\n",
        "    .value(d => d.x);\n",
        "\n",
        "  // Create histogram group\n",
        "  const histogramGroup = histogramSvg.append(\"g\");\n",
        "\n",
        "  // Add axes\n",
        "  histogramSvg.append(\"g\")\n",
        "    .attr(\"transform\", `translate(0,${plotHeight - margin.bottom})`)\n",
        "    .call(d3.axisBottom(xScale));\n",
        "/*\n",
        "  histogramSvg.append(\"g\")\n",
        "    .attr(\"transform\", `translate(${margin.left},0)`)\n",
        "    .call(d3.axisLeft(yScale));\n",
        "*/\n",
        "  // Animation function\n",
        "  function animate() {\n",
        "    particles.forEach(particle => {\n",
        "      // Random walk implementation based on diffusion equation\n",
        "      const randomAngle = Math.random() * 2 * Math.PI;\n",
        "      const displacement = Math.sqrt(2 * D);\n",
        "\n",
        "      particle.x += displacement * Math.cos(randomAngle);\n",
        "      particle.y += displacement * Math.sin(randomAngle);\n",
        "\n",
        "      // Bounce off walls\n",
        "      if (particle.x < 0) particle.x = 0;\n",
        "      if (particle.x > width) particle.x = width;\n",
        "      if (particle.y < 0) particle.y = 0;\n",
        "      if (particle.y > (height - plotHeight)) particle.y = height - plotHeight;\n",
        "    });\n",
        "\n",
        "    // Update particle positions\n",
        "    circles\n",
        "      .attr(\"cx\", d => d.x)\n",
        "      .attr(\"cy\", d => d.y);\n",
        "\n",
        "    // Update histogram\n",
        "    const bins = histogram(particles);\n",
        "\n",
        "    const bars = histogramGroup.selectAll(\"rect\")\n",
        "      .data(bins);\n",
        "\n",
        "    bars.enter()\n",
        "      .append(\"rect\")\n",
        "      .merge(bars)\n",
        "      .attr(\"x\", d => xScale(d.x0))\n",
        "      .attr(\"y\", d => yScale(d.length))\n",
        "      .attr(\"width\", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))\n",
        "      .attr(\"height\", d => yScale(0) - yScale(d.length))\n",
        "      .attr(\"fill\", \"steelblue\");\n",
        "\n",
        "    bars.exit().remove();\n",
        "  }\n",
        "\n",
        "  // Create circles for particles\n",
        "  const circles = svg.selectAll(\"circle\")\n",
        "    .data(particles)\n",
        "    .join(\"circle\")\n",
        "    .attr(\"r\", 2)\n",
        "    .attr(\"fill\", \"steelblue\")\n",
        "    .attr(\"opacity\", 0.6);\n",
        "\n",
        "  // Start animation\n",
        "  d3.timer(animate);\n",
        "\n",
        "  return container.node();\n",
        "}\n",
        "```\n",
        "Simulation showing the diffusion of particles in a 2D box. Particles move randomly based on the diffusion equation. The histogram shows the distribution of particles along the x-axis.\n",
        "\n",
        ":::\n",
        "***\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "### Spatial derivative\n",
        "\n",
        "### Spatial derivative\n",
        "\n",
        "Let's break down how we handle changes in space. Just like before, we can estimate how quickly the concentration changes in space using three points:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial^{2} c(x,t)}{\\partial x^2}\\approx\\frac{c_{i+1}^{n}-2c_{i}^{n}+c_{i-1}^{n}}{\\Delta x^2}\n",
        "\\end{equation}\n",
        "\n",
        "Think of this as looking at how the concentration changes between neighboring points. We'll collect all these concentrations at a particular time $n$ into a list: ${\\bf C}=\\lbrace c_{0}^{n},c_{1}^{n},c_{2}^{n}, \\ldots, c_{5}^{n}\\rbrace$.\n",
        "\n",
        "To make calculations easier for the computer, we can write this as a matrix equation:\n",
        "\n",
        "$M=\\frac{\\partial^2}{\\partial x^2}=\\frac{1}{\\delta x^2}\n",
        "\\begin{bmatrix}\n",
        "-2 & 1  & 0 & 0 & 0 & 0\\\\\n",
        " 1 & -2 & 1 & 0 & 0 & 0\\\\\n",
        " 0 & 1  & -2 & 1 & 0 & 0\\\\\n",
        " 0 & 0  & 1  & -2 & 1 & 0\\\\\n",
        " 0 & 0  & 0  &  1 & -2 & 1\\\\\n",
        " 0 & 0  & 0  &  0 &  1 & -2\\\\\n",
        "\\end{bmatrix}\n",
        "$\n",
        "\n",
        "Each row in this matrix represents how we calculate the change at one point using its neighbors. We haven't yet considered what happens at the edges of our system (the boundary conditions).\n",
        "\n",
        "This lets us write our diffusion equation in a simpler form:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c(x,t)}{\\partial t}\\approx DM{\\bf C}^{n}\n",
        "\\end{equation}\n",
        "\n",
        "Here, $M$ is our matrix from above, and ${\\bf C}$ is our list of concentrations. The $n$ tells us we're looking at a specific moment in time.\n",
        "\n",
        "### Temporal derivative\n",
        "\n",
        "Just like we split up space into points, we also need to split up time into small steps. The change in concentration over time can be estimated by looking at how much it changes between two time steps:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c(x,t)}{\\partial t}=\\frac{c_{i}^{n+1}-c_{i}^{n}}{\\delta t}\n",
        "\\end{equation}\n",
        "\n",
        "Here, $n$ tells us which time step we're on (just like $i$ told us which space point we were looking at). This equation works for any point in space $i$.\n",
        "\n",
        "To make our calculation more accurate, we use something called the Crank Nicolson scheme. First, we write our time derivative as:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c}{\\partial t} = f(x)\n",
        "\\end{equation}\n",
        "\n",
        "where $f(x)$ is the spatial part we found earlier:\n",
        "\n",
        "\\begin{equation}\n",
        "f(x)=D\\frac{\\partial^2 c(x,t)}{\\partial x^{2}}\n",
        "\\end{equation}\n",
        "\n",
        "The Crank Nicolson scheme tells us to take the average of this function at the current time step and the next time step:\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{\\partial c}{\\partial t} \\approx \\frac{1}{2}\\left ( f^{n+1}(x)+f^{n}(x)\\right)\n",
        "\\end{equation}\n",
        "\n",
        "where $n$ keeps track of which time step we're on.\n",
        "\n",
        "### Bringing all together\n",
        "\n",
        "We can now bring all sides together to develop our implicit scheme.\n",
        "\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{{\\bf C^{n+1}}-{\\bf C}^{n}}{\\delta t}=\\frac{1}{2} \\left (D M {\\bf C}^{n+1}+D M {\\bf C}^{n} \\right)\n",
        "\\end{equation}\n",
        "\n",
        "We can transform the last equation to yield the value of of the concentration at the time index $n+1$, i.e.\n",
        "\n",
        "\n",
        "\\begin{equation}\n",
        "\\left({\\bf I}-\\frac{\\delta t}{2}D M \\right ){\\bf C}^{n+1}=\\left({\\bf I}+\\frac{\\delta t}{2}D M \\right ){\\bf C}^{n}\n",
        "\\end{equation}\n",
        "\n",
        "where ${\\bf I}$ is the identity matrix. This will correspond in our code to\n",
        "\n",
        "\\begin{equation}\n",
        "{\\bf A}{\\bf C}^{n+1}={\\bf B}{\\bf C}^{n}\n",
        "\\end{equation}\n",
        "\n",
        "where ${\\bf A}=\\left({\\bf I}-\\frac{\\delta t}{2}D M \\right )$ and ${\\bf B}=\\left({\\bf I}+\\frac{\\delta t}{2}D M \\right )$.\n",
        "\n",
        "## Numerical Solution\n",
        "\n",
        "We are now ready to write some code. To simulate diffusion, we need two key pieces of information: what happens at the edges of our system (boundary conditions) and how the concentration looks at the start (initial condition).\n",
        "\n",
        "Let's imagine we're looking at diffusion along a line of length L=1. At both ends of this line (x=0 and x=L), we'll keep the concentration at zero throughout the simulation. This might represent, for example, a situation where any particles that reach the edges are immediately removed:\n",
        "\n",
        "\\begin{equation}\n",
        "c(0,t)=c(L,t)=0\n",
        "\\end{equation}\n",
        "\n",
        "For our starting condition, we'll create a bell-shaped curve (Gaussian distribution) centered in the middle of our line (at x=L/2). This is like placing a concentrated drop of ink at the center:\n",
        "\n",
        "\\begin{equation}\n",
        "c(x,0)=\\frac{1}{\\sigma\\sqrt{2\\pi }}e^{-\\frac{(x-L/2)^2}{2\\sigma^2}}\n",
        "\\end{equation}\n",
        "\n",
        "Here, σ=0.05 controls how narrow or wide our initial distribution is - a smaller σ means a more concentrated initial drop.\n",
        "\n",
        "### Setup Domain\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "L=1.0 ## domain size\n",
        "\n",
        "NX = 500 ## data points along position direction\n",
        "\n",
        "dx = 1/(NX+1.0) ## position intervall\n",
        "x = np.linspace(0,L,NX+2) ## position vector\n",
        "x = x[1:-1] ## just skip the position at the beginning and end of the vector due to the boundary conditions\n",
        "\n",
        "T = 0.5 ## time intervall\n",
        "dt = dx/4 ## time step\n",
        "NT = int(T/dt) ## number of time steps\n",
        "\n",
        "D=0.1 ## diffusion coefficient\n",
        "```\n",
        "\n",
        "### Initial Conditions\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "sigma=0.04 ## initial distribution width\n",
        "c = np.exp(-(x-L/2)**2/(2*sigma**2))  # no need for transpose here if x is 1D\n",
        "c = c.reshape(-1)  # ensure it's a 1D array\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "plt.figure(figsize=get_size(12, 8))\n",
        "plt.xlabel('position x')\n",
        "plt.ylabel('concentration c')\n",
        "plt.plot(x,c)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "### Matrix Setup\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "## the setup is a bit different from the scipy.diags, so we learn something new ;-)\n",
        "data = np.ones((3, NX))\n",
        "data[1] = -2*data[1]\n",
        "diags = [-1,0,1]\n",
        "M = sparse.spdiags(data,diags,NX,NX)/(dx**2)\n",
        "\n",
        "# Identity Matrix\n",
        "I = sparse.identity(NX)\n",
        "\n",
        "```\n",
        "\n",
        "### Solution\n",
        "\n",
        "To solve this system of equations, we'll use the `spsolve` function from the `scipy.sparse.linalg` module. This function is designed to solve sparse linear systems efficiently. Here is a detailed explanation of the code:\n",
        "\n",
        "```python\n",
        "data = []                      #<1>\n",
        "data.append(c)                 #<2>\n",
        "\n",
        "for i in range(NT):           #<3>\n",
        "    A = (I -dt/2*D*M)         #<4>\n",
        "    B = (I + dt/2*D*M)*c      #<5>\n",
        "    c = sparse.linalg.spsolve(A, B)  #<6>\n",
        "    c = np.array(c)           #<7>\n",
        "    data.append(c)            #<8>\n",
        "```\n",
        "1. Initialize empty list to store concentration profiles\n",
        "2. Store initial condition as first element\n",
        "3. Loop over all time steps\n",
        "4. Create matrix A for left side of equation: (I - dt/2*D*∂²/∂x²)\n",
        "5. Create matrix B times current concentration: (I + dt/2*D*∂²/∂x²)*c^n\n",
        "6. Solve linear system A*c^(n+1) = B*c^n for next time step\n",
        "7. Convert solution to numpy array for consistency\n",
        "8. Store concentration profile of current time step\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "data = [] ## store the solutions for the individual timesteps\n",
        "data.append(c)\n",
        "for i in range(NT): ## loop over all timesteps\n",
        "\n",
        "    A = (I -dt/2*D*M) ## matrix multiplied to the next timestep solution\n",
        "    B = ( I + dt/2*D*M )*c ## matrix multiplied to the current timestep solution, which is c\n",
        "    c = sparse.linalg.spsolve(A, B)  # returns numpy array\n",
        "    c = np.array(c)  # ensure it's numpy array (redundant but safe)\n",
        "\n",
        "    data.append(c)\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=get_size(12, 8))\n",
        "for i in range(0,NT,10):\n",
        "    plt.plot(x,data[i])\n",
        "\n",
        "plt.xlabel('position x')\n",
        "plt.ylabel('concentration c')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=get_size(12, 8))\n",
        "plt.imshow(np.array(data,dtype=float).reshape(NT+1, NX),  # NT+1 because we included initial condition\n",
        "          vmin=0, vmax=0.5,\n",
        "          cmap='gray_r',\n",
        "          extent=(0,L,T,0))  # extent defines the axis limits\n",
        "plt.xlabel('position x')\n",
        "plt.ylabel('time t')\n",
        "plt.colorbar(label='concentration')  # adding a colorbar is helpful\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Where to go from here\n",
        "\n",
        "The diffusion equation we have solved here is a simple example of a partial differential equation. A similar type of equation is the heat equation, which describes how heat spreads in a material. Finally, also the Schrödinger equation is a partial differential equation, which describes the time evolution of a quantum system. You could apply your knowledge of the diffusion equation to solve these more complex problems."
      ],
      "id": "b41c176e"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}