{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Repetition\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.integrate import odeint\n",
        "\n",
        "# Set default plotting parameters\n",
        "plt.rcParams.update({\n",
        "    'font.size': 12,\n",
        "    'lines.linewidth': 1,\n",
        "    'lines.markersize': 5,\n",
        "    'axes.labelsize': 11,\n",
        "    'xtick.labelsize': 10,\n",
        "    'ytick.labelsize': 10,\n",
        "    'xtick.top': True,\n",
        "    'xtick.direction': 'in',\n",
        "    'ytick.right': True,\n",
        "    'ytick.direction': 'in',\n",
        "})\n",
        "\n",
        "def get_size(w, h):\n",
        "    return (w/2.54, h/2.54)\n",
        "```\n",
        "\n",
        "After we have completed the first part of the course, we will have a repetition session to review the main concepts and topics covered so far. This will help reinforce your understanding and prepare you for the final exam. This part contains a number of exercises you can work on to test your knowledge and skills.\n",
        "\n",
        "## What is a Program?\n",
        "A program is a sequence of instructions that tells a computer how to perform a specific task. These instructions must be:\n",
        "\n",
        "- Precise and unambiguous\n",
        "- Written in a language the computer understands\n",
        "- Logically structured\n",
        "- Designed to achieve a specific goal\n",
        "\n",
        "## Basic Elements of Python\n",
        "\n",
        "### Variables and Data Types\n",
        "In Python, variables are containers for storing data values. Python is dynamically typed, meaning you don't need to declare variable types explicitly.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# Basic data types\n",
        "x = 5           # integer\n",
        "y = 3.14        # float\n",
        "name = \"Python\" # string\n",
        "is_true = True  # boolean\n",
        "\n",
        "# Print variable types\n",
        "print(f\"x is type: {type(x)}\")\n",
        "print(f\"y is type: {type(y)}\")\n",
        "print(f\"name is type: {type(name)}\")\n",
        "print(f\"is_true is type: {type(is_true)}\")\n",
        "```\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 1: Unit Conversion\n",
        "Write a program that converts a temperature from Celsius to Fahrenheit and Kelvin.\n",
        "Use the formulas:\n",
        "\n",
        "- °F = (°C × 9/5) + 32\n",
        "- K = °C + 273.15\n",
        "\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_1\n",
        "\n",
        "# Example starting temperature\n",
        "celsius = 25\n",
        "\n",
        "# Calculate conversions\n",
        "# Print results\n",
        "\n",
        "____\n",
        "```\n",
        "\n",
        "::: { .solution exercise=\"ex_1\" }\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "\n",
        "celsius = 25\n",
        "fahrenheit = (celsius * 9/5) + 32\n",
        "kelvin = celsius + 273.15\n",
        "\n",
        "print(f\"{celsius}°C is equal to:\")\n",
        "print(f\"{fahrenheit}°F\")\n",
        "print(f\"{kelvin}K\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "### Numerical Operations\n",
        "Python supports all basic mathematical operations:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "a = 10\n",
        "b = 3\n",
        "\n",
        "print(f\"Addition: {a + b}\")\n",
        "print(f\"Subtraction: {a - b}\")\n",
        "print(f\"Multiplication: {a * b}\")\n",
        "print(f\"Division: {a / b}\")\n",
        "print(f\"Integer Division: {a // b}\")\n",
        "print(f\"Modulo: {a % b}\")\n",
        "print(f\"Power: {a ** b}\")\n",
        "```\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 2: Basic Kinematics\n",
        "Calculate the final velocity of an object given its initial velocity, acceleration, and time.\n",
        "Use the formula: v = v₀ + at\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_2\n",
        "# Given values\n",
        "initial_velocity = 0  # m/s\n",
        "acceleration = 9.81   # m/s²\n",
        "time = 5             # s\n",
        "\n",
        "# Calculate final velocity\n",
        "# Print result\n",
        "```\n",
        "\n",
        "::: { .solution exercise=\"ex_2\" }\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "initial_velocity = 0  # m/s\n",
        "acceleration = 9.81   # m/s²\n",
        "time = 5             # s\n",
        "\n",
        "final_velocity = initial_velocity + acceleration * time\n",
        "print(f\"Final velocity: {final_velocity} m/s\")\n",
        "\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "### Lists and Arrays\n",
        "For physics calculations, we often need to work with collections of numbers:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# List (basic Python)\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "print(f\"List: {numbers}\")\n",
        "\n",
        "# NumPy array (better for calculations)\n",
        "import numpy as np\n",
        "array = np.array([1, 2, 3, 4, 5])\n",
        "print(f\"Array: {array}\")\n",
        "print(f\"Array × 2: {array * 2}\")  # Element-wise multiplication\n",
        "```\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 3: Force Calculations\n",
        "Create an array of masses (in kg) and calculate the force of gravity on each mass.\n",
        "Use F = mg where g = 9.81 m/s². Numpy is already imported and can be used with `np`\n",
        "\n",
        "```{pyodide}\n",
        "#| setup: true\n",
        "#| exercise: ex_3\n",
        "import numpy as np\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_3\n",
        "\n",
        "# Create array of masses (kg)\n",
        "masses = np.array([1, 2, 5, 10])\n",
        "\n",
        "# Calculate forces\n",
        "# Print results\n",
        "```\n",
        "\n",
        "\n",
        "::: {.solution exercise=\"ex_3\"}\n",
        "::: {.callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# Create array of masses (kg)\n",
        "masses = np.array([1, 2, 5, 10])\n",
        "\n",
        "g = 9.81\n",
        "forces = masses * g\n",
        "for m, f in zip(masses, forces):\n",
        "    print(f\"A mass of {m}kg experiences a force of {f:.2f}N\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "## Control Structures\n",
        "\n",
        "### Conditional Statements\n",
        "Conditional statements allow programs to make decisions:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "temperature = 25\n",
        "\n",
        "if temperature > 30:\n",
        "    print(\"It's hot!\")\n",
        "elif temperature > 20:\n",
        "    print(\"It's pleasant\")\n",
        "else:\n",
        "    print(\"It's cool\")\n",
        "```\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 4: Phase of Matter\n",
        "Write a program that determines the phase of water based on its temperature\n",
        "(assume standard pressure):\n",
        "\n",
        "- Below 0°C: Solid (Ice)\n",
        "- 0-100°C: Liquid\n",
        "- Above 100°C: Gas (Steam)\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_4\n",
        "# Your code here\n",
        "temperature = 25  # °C\n",
        "\n",
        "# Determine phase\n",
        "# Print result\n",
        "```\n",
        "\n",
        ":::{ .solution exercise=\"ex_4\"}\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "if temperature < 0:\n",
        "    phase = \"Solid (Ice)\"\n",
        "elif temperature <= 100:\n",
        "    phase = \"Liquid\"\n",
        "else:\n",
        "    phase = \"Gas (Steam)\"\n",
        "print(f\"At {temperature}°C, water is in {phase} phase\")\n",
        "\"\"\"\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 5: Projectile Range Calculator\n",
        "Write a program that calculates if a projectile will hit a target given:\n",
        "\n",
        "- Initial velocity\n",
        "- Launch angle\n",
        "- Target distance\n",
        "\n",
        "Use the range formula: $R = \\frac{v_0^2 \\sin(2\\theta)}{g}$\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_5\n",
        "import numpy as np\n",
        "\n",
        "v0 = 10          # initial velocity (m/s)\n",
        "theta = 45       # angle (degrees)\n",
        "target = 8       # target distance (m)\n",
        "\n",
        "# Calculate range\n",
        "# Determine if target is hit\n",
        "# (consider it a hit if within ±0.5m)\n",
        "```\n",
        "\n",
        ":::{ .solution exercise=\"ex_5\"}\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "import numpy as np\n",
        "\n",
        "v0 = 10          # initial velocity (m/s)\n",
        "theta = 45       # angle (degrees)\n",
        "target = 8       # target distance (m)\n",
        "\n",
        "g = 9.81\n",
        "theta_rad = np.deg2rad(theta)\n",
        "range_distance = (v0**2 * np.sin(2*theta_rad)) / g\n",
        "\n",
        "if abs(range_distance - target) <= 0.5:\n",
        "    print(\"Hit!\")\n",
        "else:\n",
        "    print(\"Miss!\")\n",
        "print(f\"Projectile range: {range_distance:.2f}m\")\n",
        "print(f\"Target distance: {target}m\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "### Loops\n",
        "Loops allow repetition of code:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# For loop\n",
        "print(\"For loop:\")\n",
        "for i in range(5):\n",
        "    print(f\"i = {i}\")\n",
        "\n",
        "# While loop\n",
        "print(\"\\nWhile loop:\")\n",
        "j = 0\n",
        "while j < 3:\n",
        "    print(f\"j = {j}\")\n",
        "    j += 1\n",
        "```\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 6: Radioactive Decay Calculator\n",
        "Write a program that simulates radioactive decay over multiple half-lives:\n",
        "\n",
        "- Start with an initial number of atoms ($N_0$)\n",
        "- Calculate remaining atoms after each half-life period\n",
        "- Continue for 5 half-lives\n",
        "\n",
        "Use the formula $N(t) = N_0 \\cdot \\left(\\frac{1}{2}\\right)^{t/t_{1/2}}$ where $t_{1/2}$ is the half-life.\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_6\n",
        "import numpy as np\n",
        "\n",
        "N0 = 1000        # initial number of atoms\n",
        "half_lives = 5   # number of half-lives to simulate\n",
        "\n",
        "# Create a loop that:\n",
        "# 1. Calculates remaining atoms for each half-life\n",
        "# 2. Prints the time (in half-lives) and remaining atoms\n",
        "# 3. Runs for 5 half-lives\n",
        "```\n",
        "\n",
        ":::{ .solution exercise=\"ex_6\"}\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "import numpy as np\n",
        "\n",
        "N0 = 1000        # initial number of atoms\n",
        "half_lives = 5   # number of half-lives to simulate\n",
        "\n",
        "for t in range(half_lives + 1):  # +1 to include initial state\n",
        "    N = N0 * (0.5)**t\n",
        "    print(f\"After {t} half-lives: {int(N)} atoms remaining\")\n",
        "    print(f\"Percentage remaining: {(N/N0 * 100):.1f}%\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Self-Exercise 7: Time to Ground Calculator\n",
        "Write a program that calculates how long it takes for an object to reach the ground when dropped from different heights:\n",
        "\n",
        "- Start with an initial height $h_0$\n",
        "- Calculate position using $y = h_0 - \\frac{1}{2}gt^2$\n",
        "- Find the time when $y = 0$\n",
        "- Use small time steps ($dt = 0.01s$)\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_7\n",
        "import numpy as np\n",
        "\n",
        "height = 100     # initial height in meters\n",
        "g = 9.81        # acceleration due to gravity\n",
        "dt = 0.01       # time step in seconds\n",
        "\n",
        "# Create a while loop that:\n",
        "# 1. Updates the position using y = y₀ - ½gt²\n",
        "# 2. Tracks the elapsed time\n",
        "# 3. Stops when object hits ground (y ≤ 0)\n",
        "```\n",
        "\n",
        ":::{ .solution exercise=\"ex_7\"}\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "import numpy as np\n",
        "\n",
        "height = 100     # initial height in meters\n",
        "g = 9.81        # acceleration due to gravity\n",
        "dt = 0.01       # time step in seconds\n",
        "\n",
        "time = 0\n",
        "y = height\n",
        "\n",
        "while y > 0:\n",
        "    time += dt\n",
        "    y = height - 0.5 * g * time**2\n",
        "\n",
        "print(f\"Time to reach ground: {time:.2f} seconds\")\n",
        "print(f\"Theoretical time: {np.sqrt(2*height/g):.2f} seconds\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "# Scientific Computing\n",
        "\n",
        "## Basic Numerical Calculations\n",
        "For physics, we often use NumPy for numerical calculations:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "import numpy as np\n",
        "\n",
        "# Create array of angles (in radians)\n",
        "angles = np.linspace(0, 2*np.pi, 5)\n",
        "\n",
        "# Calculate sine and cosine\n",
        "sines = np.sin(angles)\n",
        "cosines = np.cos(angles)\n",
        "\n",
        "# Print results\n",
        "for angle, sin_val, cos_val in zip(angles, sines, cosines):\n",
        "    print(f\"Angle: {angle:.2f}, sin: {sin_val:.2f}, cos: {cos_val:.2f}\")\n",
        "```\n",
        "\n",
        "## Simple Physics Example\n",
        "Let's calculate the position of a projectile under gravity:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "# Initial conditions\n",
        "v0 = 10  # initial velocity (m/s)\n",
        "theta = 45  # angle (degrees)\n",
        "g = 9.81  # gravitational acceleration (m/s²)\n",
        "\n",
        "# Convert angle to radians\n",
        "theta_rad = np.deg2rad(theta)\n",
        "\n",
        "# Time array\n",
        "t = np.linspace(0, 2*v0*np.sin(theta_rad)/g, 100)\n",
        "\n",
        "# Position calculations\n",
        "x = v0 * np.cos(theta_rad) * t\n",
        "y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2\n",
        "\n",
        "# Plot trajectory\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "plt.plot(x, y)\n",
        "plt.grid(True)\n",
        "plt.xlabel('Distance (m)')\n",
        "plt.ylabel('Height (m)')\n",
        "plt.title('Projectile Motion')\n",
        "plt.axis('equal')\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "# Best Practices\n",
        "\n",
        "## Code Organization\n",
        "- Use meaningful variable names\n",
        "- Add comments to explain complex logic\n",
        "- Break down complex problems into smaller functions\n",
        "- Use consistent indentation\n",
        "\n",
        "## Example of Well-Organized Code\n",
        "Here's an example calculating the period of a simple pendulum:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "def calculate_pendulum_period(length, gravity=9.81):\n",
        "    \"\"\"\n",
        "    Calculate the period of a simple pendulum.\n",
        "\n",
        "    Parameters:\n",
        "    length (float): Length of pendulum in meters\n",
        "    gravity (float): Gravitational acceleration in m/s²\n",
        "\n",
        "    Returns:\n",
        "    float: Period in seconds\n",
        "    \"\"\"\n",
        "    import numpy as np\n",
        "\n",
        "    # Calculate period using T = 2π√(L/g)\n",
        "    period = 2 * np.pi * np.sqrt(length/gravity)\n",
        "    return period\n",
        "\n",
        "# Example usage\n",
        "L = 1.0  # 1 meter pendulum\n",
        "T = calculate_pendulum_period(L)\n",
        "print(f\"A {L}m pendulum has a period of {T:.2f} seconds\")\n",
        "```\n",
        "\n",
        "# Object-Oriented Programming in Python\n",
        "\n",
        "## Classes and Objects\n",
        "Classes are blueprints for creating objects that combine data (attributes) and functions (methods). This is particularly useful for modeling physical systems.\n",
        "\n",
        "### Basic Class Structure\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "class Particle:\n",
        "    \"\"\"A simple class representing a particle in 2D space.\"\"\"\n",
        "\n",
        "    def __init__(self, x, y, mass=1.0):\n",
        "        \"\"\"Initialize particle with position and mass.\"\"\"\n",
        "        self.x = x\n",
        "        self.y = y\n",
        "        self.mass = mass\n",
        "        self.vx = 0  # initial velocity components\n",
        "        self.vy = 0\n",
        "\n",
        "    def set_velocity(self, vx, vy):\n",
        "        \"\"\"Set particle velocity.\"\"\"\n",
        "        self.vx = vx\n",
        "        self.vy = vy\n",
        "\n",
        "    def kinetic_energy(self):\n",
        "        \"\"\"Calculate kinetic energy of particle.\"\"\"\n",
        "        return 0.5 * self.mass * (self.vx**2 + self.vy**2)\n",
        "\n",
        "    def __str__(self):\n",
        "        \"\"\"String representation of particle.\"\"\"\n",
        "        return f\"Particle at ({self.x}, {self.y}) with mass {self.mass}\"\n",
        "\n",
        "# Create and use a particle object\n",
        "p1 = Particle(0, 0, mass=2.0)\n",
        "p1.set_velocity(3, 4)\n",
        "print(p1)\n",
        "print(f\"Kinetic energy: {p1.kinetic_energy()} J\")\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "::: {.callout-note collapse=\"true\"}\n",
        "### Advanced Self-Exercise 8: Electric Charge Class\n",
        "Create a class representing an electric charge that can:\n",
        "\n",
        "1. Store position $(x, y)$, charge magnitude $(q)$, and mass $(m)$\n",
        "2. Calculate electric potential at a point using $V = \\frac{kq}{r}$\n",
        "3. Calculate electric force on another charge using $F = \\frac{kq_1q_2}{r^2}$\n",
        "4. Calculate the direction of force (attraction/repulsion)\n",
        "\n",
        "Use $k = 8.99 \\times 10^9$ N$\\cdot$m²/C² (Coulomb's constant)\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_8\n",
        "import numpy as np\n",
        "\n",
        "# Create your ElectricCharge class here\n",
        "# Include methods for:\n",
        "# - initialization (__init__)\n",
        "# - calculating potential\n",
        "# - calculating force\n",
        "# - string representation (__str__)\n",
        "\n",
        "```\n",
        "\n",
        ":::{ .solution exercise=\"ex_8\"}\n",
        "::: { .callout-tip collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "import numpy as np\n",
        "\n",
        "class ElectricCharge:\n",
        "    \"\"\"A class representing an electric charge in 2D space.\"\"\"\n",
        "\n",
        "    k = 8.99e9  # Coulomb's constant\n",
        "\n",
        "    def __init__(self, x, y, charge, mass=1.0):\n",
        "        \"\"\"Initialize charge with position, charge magnitude, and mass.\"\"\"\n",
        "        self.x = x\n",
        "        self.y = y\n",
        "        self.q = charge\n",
        "        self.mass = mass\n",
        "\n",
        "    def distance_to(self, other):\n",
        "        \"\"\"Calculate distance to another charge.\"\"\"\n",
        "        dx = self.x - other.x\n",
        "        dy = self.y - other.y\n",
        "        return np.sqrt(dx**2 + dy**2)\n",
        "\n",
        "    def potential_at_point(self, x, y):\n",
        "        \"\"\"Calculate electric potential at a point.\"\"\"\n",
        "        r = np.sqrt((self.x - x)**2 + (self.y - y)**2)\n",
        "        if r < 1e-10:  # Avoid division by zero\n",
        "            return float('inf')\n",
        "        return self.k * self.q / r\n",
        "\n",
        "    def force_with(self, other):\n",
        "        \"\"\"Calculate electric force with another charge.\"\"\"\n",
        "        r = self.distance_to(other)\n",
        "        if r < 1e-10:  # Avoid division by zero\n",
        "            return 0\n",
        "        force_magnitude = self.k * abs(self.q * other.q) / (r**2)\n",
        "        # Determine if attractive (opposite charges) or repulsive (same charges)\n",
        "        direction = \"attractive\" if self.q * other.q < 0 else \"repulsive\"\n",
        "        return force_magnitude, direction\n",
        "\n",
        "    def __str__(self):\n",
        "        \"\"\"String representation of the charge.\"\"\"\n",
        "        return f\"Charge of {self.q}C at ({self.x}, {self.y})\"\n",
        "\n",
        "# Test the class\n",
        "q1 = ElectricCharge(0, 0, 1e-6)  # 1 µC at origin\n",
        "q2 = ElectricCharge(0.1, 0, -1e-6)  # -1 µC at x=0.1m\n",
        "\n",
        "# Calculate force between charges\n",
        "force, direction = q1.force_with(q2)\n",
        "print(f\"Force between charges: {force:.2e} N ({direction})\")\n",
        "\n",
        "# Calculate potential at a point\n",
        "potential = q1.potential_at_point(0.05, 0)\n",
        "print(f\"Electric potential at (0.05, 0): {potential:.2e} V\")\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## A Physics Example: Harmonic Oscillator\n",
        "Here's a more complete example modeling a harmonic oscillator:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "class HarmonicOscillator:\n",
        "    \"\"\"Class representing a simple harmonic oscillator.\"\"\"\n",
        "\n",
        "    def __init__(self, mass, spring_constant):\n",
        "        \"\"\"\n",
        "        Initialize oscillator.\n",
        "\n",
        "        Parameters:\n",
        "        mass (float): Mass in kg\n",
        "        spring_constant (float): Spring constant in N/m\n",
        "        \"\"\"\n",
        "        self.m = mass\n",
        "        self.k = spring_constant\n",
        "        self.x = 0  # position\n",
        "        self.v = 0  # velocity\n",
        "\n",
        "    def period(self):\n",
        "        \"\"\"Calculate the period of oscillation.\"\"\"\n",
        "        return 2 * np.pi * np.sqrt(self.m / self.k)\n",
        "\n",
        "    def energy(self):\n",
        "        \"\"\"Calculate total energy (kinetic + potential).\"\"\"\n",
        "        kinetic = 0.5 * self.m * self.v**2\n",
        "        potential = 0.5 * self.k * self.x**2\n",
        "        return kinetic + potential\n",
        "\n",
        "    def update_state(self, dt):\n",
        "        \"\"\"Update position and velocity after time dt.\"\"\"\n",
        "        # Simple Euler integration (not ideal for accurate simulation)\n",
        "        F = -self.k * self.x  # spring force\n",
        "        a = F / self.m        # acceleration\n",
        "        self.v += a * dt      # update velocity\n",
        "        self.x += self.v * dt # update position\n",
        "\n",
        "# Create and use an oscillator\n",
        "osc = HarmonicOscillator(mass=1.0, spring_constant=10.0)\n",
        "print(f\"Period: {osc.period():.2f} s\")\n",
        "\n",
        "# Simulate motion\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Initial conditions\n",
        "osc.x = 1.0  # start at x = 1 m\n",
        "time = np.linspace(0, 2*osc.period(), 100)\n",
        "positions = []\n",
        "\n",
        "# Run simulation\n",
        "for t in time:\n",
        "    positions.append(osc.x)\n",
        "    osc.update_state(time[1] - time[0])\n",
        "\n",
        "# Plot results\n",
        "plt.figure(figsize=(8, 6))\n",
        "plt.plot(time, positions)\n",
        "plt.xlabel('Time (s)')\n",
        "plt.ylabel('Position (m)')\n",
        "plt.title('Simple Harmonic Motion')\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Inheritance\n",
        "Classes can inherit properties and methods from other classes:\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "class ChargedParticle(Particle):\n",
        "    \"\"\"A particle with electric charge, inheriting from Particle.\"\"\"\n",
        "\n",
        "    def __init__(self, x, y, mass=1.0, charge=1.0):\n",
        "        \"\"\"Initialize charged particle.\"\"\"\n",
        "        super().__init__(x, y, mass)  # call parent class initializer\n",
        "        self.charge = charge\n",
        "\n",
        "    def potential_energy(self, electric_field):\n",
        "        \"\"\"Calculate potential energy in electric field.\"\"\"\n",
        "        return -self.charge * electric_field * self.y\n",
        "\n",
        "    def __str__(self):\n",
        "        \"\"\"Override string representation to include charge.\"\"\"\n",
        "        return f\"Charged Particle at ({self.x}, {self.y}) with q={self.charge}\"\n",
        "\n",
        "# Create and use a charged particle\n",
        "electron = ChargedParticle(0, 2, mass=9.1e-31, charge=-1.6e-19)\n",
        "print(electron)\n",
        "E_field = 1000  # V/m\n",
        "print(f\"Potential energy in field: {electron.potential_energy(E_field):.2e} J\")\n",
        "```\n",
        "\n",
        "## Key Points About Classes\n",
        "\n",
        "1. Classes combine data (attributes) and functions (methods)\n",
        "2. The `__init__` method initializes new objects\n",
        "3. `self` refers to the instance of the class\n",
        "4. Methods can modify the object's state\n",
        "5. Inheritance allows creating specialized versions of classes\n",
        "6. Classes help organize code and model real-world systems\n",
        "\n",
        "Classes are particularly useful in physics for:\n",
        "- Modeling physical systems\n",
        "- Organizing simulation code\n",
        "- Creating reusable components\n",
        "- Building hierarchies of related objects\n",
        "\n",
        "\n",
        "# Common Pitfalls and Tips\n",
        "\n",
        "1. Remember that Python is zero-indexed (lists start at 0)\n",
        "2. Be careful with indentation - it defines code blocks\n",
        "3. Use `numpy` for numerical calculations instead of lists\n",
        "4. Always check variable types when debugging\n",
        "5. Use meaningful variable names\n",
        "6. Add comments to explain your code\n",
        "7. Break complex problems into smaller steps\n",
        "\n",
        "# Further Resources\n",
        "\n",
        "- Python documentation: [python.org](https://docs.python.org)\n",
        "- NumPy documentation: [numpy.org](https://numpy.org/doc)\n",
        "- SciPy documentation: [scipy.org](https://docs.scipy.org)\n",
        "- Matplotlib documentation: [matplotlib.org](https://matplotlib.org/docs)"
      ],
      "id": "3593ebf8"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}