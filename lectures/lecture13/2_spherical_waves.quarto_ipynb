{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Spherical waves\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "After we have had a look at plane waves, we can explore a second solution of the homogeneous wave equation - **Spherical Waves**. Spherical waves are elementary waves that are for example considered in Huygens principle. So if we develop some code to visualize spherical waves, we may also verify Huygens principle later.\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.integrate import odeint\n",
        "\n",
        "# Set default plotting parameters\n",
        "plt.rcParams.update({\n",
        "    'font.size': 12,\n",
        "    'lines.linewidth': 1,\n",
        "    'lines.markersize': 5,\n",
        "    'axes.labelsize': 11,\n",
        "    'xtick.labelsize': 10,\n",
        "    'ytick.labelsize': 10,\n",
        "    'xtick.top': True,\n",
        "    'xtick.direction': 'in',\n",
        "    'ytick.right': True,\n",
        "    'ytick.direction': 'in',\n",
        "})\n",
        "\n",
        "def get_size(w, h):\n",
        "    return (w/2.54, h/2.54)\n",
        "```\n",
        "\n",
        "## Equations\n",
        "\n",
        "A spherical wave is as well described by two exponentials containing the spatial and temporal dependence of the wave. The only difference is, that the wavefronts shall describe spheres instead of planes. We therefore need $|\\vec{k}||\\vec{r}|=k r=const$. The product of the magntitudes of the wavevector and the distance from the source are constant. If we further generalize the position of the source to $\\vec{r}_{0}$ we can write a spherical wave by\n",
        "\n",
        "\\begin{equation}\n",
        "E=\\frac{E_{0}}{|\\vec{r}-\\vec{r}_{0}|}e^{i k|\\vec{r}-\\vec{r}_{0}|} e^{-i\\omega t}\n",
        "\\end{equation}\n",
        "\n",
        "Note that we have to introduce an additional scaling of the amplitude with the inverse distance of the source. This is due to energy conservation, as we require that all the energy that flows through all spheres around the source is constant.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "def spherical_wave(k,omega,r,r0,t):\n",
        "    k=np.linalg.norm(k)\n",
        "    d=np.linalg.norm(r-r0)\n",
        "    return( np.exp(1j*(k*d-omega*t))/d)\n",
        "```\n",
        "\n",
        "## Electric field\n",
        "\n",
        "Lets have a look at the electric field of the spherical wave. Below is some code plotting the electric field is space. The source is at the origin and the plot nicely shows, that the amplitude decays with the distance.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "plt.figure(figsize=(5,5))\n",
        "\n",
        "x=np.linspace(-5e-6,5e-6,300)\n",
        "z=np.linspace(-5e-6,5e-6,300)\n",
        "\n",
        "X,Z=np.meshgrid(x,z)\n",
        "r=np.array([X,0,Z],dtype=object) # dtype=object is correct for new numpy versions\n",
        "\n",
        "wavelength=532e-9\n",
        "k0=2*np.pi/wavelength\n",
        "c=299792458\n",
        "omega0=k0*c\n",
        "\n",
        "k=k0*np.array([0,0,1.])\n",
        "r0=np.array([0,0,0])\n",
        "\n",
        "field=spherical_wave(k,omega0,r,r0,0)\n",
        "\n",
        "extent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\n",
        "plt.imshow(np.real(field.transpose()),extent=extent,vmin=-5e6,vmax=5e6,cmap='seismic')\n",
        "\n",
        "plt.xlabel('z [µm]')\n",
        "plt.ylabel('x [µm]')\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "The line plots below show that the field amplitude rapidly decays and the intensity follows a $1/r^2$ law as expected. The slight deiviation at small distances is an artifact from our discretization. We used the image above to extract the line plot and therefore never exactly hit $r=0$.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "plt.figure(figsize=get_size(16,8))\n",
        "plt.subplot(1,2,1)\n",
        "plt.plot(z*1e6,np.real(field.transpose()[150,:]))\n",
        "plt.xlabel('z in [µm]')\n",
        "plt.ylabel('electric field [a.u.]')\n",
        "\n",
        "\n",
        "plt.subplot(1,2,2)\n",
        "plt.loglog(z*1e6,1/(z**2),'k--',label='$1/r^2$')\n",
        "plt.loglog(z*1e6,np.abs(field.transpose()[150,:])**2,color='k',alpha=0.2,lw=4,label='intensity')\n",
        "plt.xlabel('z in [µm]')\n",
        "plt.xlim(2e-2,)\n",
        "plt.ylabel('intensity [a.u.]')\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Animation\n",
        "\n",
        "We can also visualize the animation our spherical wave to check for the direction of the wave propagation.\n",
        "\n",
        "```python\n",
        "norm = mpl.colors.Normalize(vmin=-5e6, vmax=5e6)\n",
        "cmap = cm.seismic\n",
        "m = cm.ScalarMappable(norm=norm, cmap=cmap)\n",
        "```\n",
        "\n",
        "```python\n",
        "canvas = Canvas(width=300, height=300,sync_image_data=True)\n",
        "display(canvas)\n",
        "```\n",
        "\n",
        "```python\n",
        "def animate(k,time):\n",
        "    for t in time:\n",
        "        field=spherical_wave(k,omega0,r,r0,t)\n",
        "        data=np.zeros([300,300,3])\n",
        "        tmp=np.real(field.transpose())\n",
        "        c=m.to_rgba(tmp)\n",
        "        with hold_canvas(canvas):\n",
        "            canvas.put_image_data(c[:,:,:3]*255,0,0)\n",
        "        sleep(0.02)\n",
        "```\n",
        "\n",
        "```python\n",
        "time= np.linspace(0,1e-14,200)\n",
        "animate(k,time)\n",
        "```\n",
        "\n",
        "## Plot the intensity in an image plane\n",
        "\n",
        "As we have now the electric field in space, wqe may also chose an arbitrary plane in space to record the intensity of that wave in space. Here we want to know the intensity in a plane at 10 µm distance from the source, which is again at the origin. The intensity cross section at the screen is a Lorentzian function.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "plt.figure(figsize=get_size(16,8))\n",
        "x=np.linspace(-50e-6,50e-6,200)\n",
        "y=np.linspace(-50e-6,50e-6,200)\n",
        "\n",
        "X,Y=np.meshgrid(x,y)\n",
        "r=np.array([X,Y,10e-6],dtype=object) # dtype=object is correct for new numpy versions\n",
        "k1=2*np.pi/wavelength*np.array([0j,0j,1+0j])\n",
        "r0=np.array([0,0,0])\n",
        "field=spherical_wave(k1,omega0,r,r0,0)\n",
        "\n",
        "plt.subplot(1,2,1)\n",
        "plt.imshow(np.abs(field)**2,extent=[-50,50,-50,50],cmap='gray_r')\n",
        "plt.xlabel('y [µm]')\n",
        "plt.ylabel('x [µm]')\n",
        "\n",
        "plt.subplot(1,2,2)\n",
        "plt.plot(x,np.abs(field[100,:])**2)\n",
        "#plt.plot(x,3e10/((178000*x)**2+3))\n",
        "\n",
        "plt.xlabel('x [µm]')\n",
        "plt.ylabel('intensity [µm]')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "## Interference between a spherical and a plane wave\n",
        "\n",
        "In the section on plane waves, we had a look at the interference pattern of plane waves in space. We now have a look at the interference of a plane wave and a spherical wave. The plane wave thereby probes the distortion of the spherical wavefronts and the interference pattern stores this information on the shape of the spherical wavefronts. This is exactly what is done in holography. Taking this interference pattern as a \"diffraction grating\" will  allow you to restore information on the spherical wavefonts.\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "def plane_wave(k,omega,r,t):\n",
        "    return(np.exp(1j*(np.dot(k,r)-omega*t)))\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "#| autorun: false\n",
        "plt.figure(figsize=get_size(16,8))\n",
        "x=np.linspace(-10e-6,10e-6,1000)\n",
        "y=np.linspace(-10e-6,10e-6,1000)\n",
        "\n",
        "X,Y=np.meshgrid(x,y)\n",
        "r=np.array([X,Y,10e-6],dtype=object) # dtype=object is correct for new numpy versions\n",
        "k1=2*np.pi/wavelength*np.array([0j,1+0j,0j])\n",
        "r0=np.array([0,0,0])\n",
        "\n",
        "field=plane_wave(k1,omega0,r,0)+0.000005*spherical_wave(k1,omega0,r,r0,0)\n",
        "extent = np.min(y)*1e6, np.max(y)*1e6,np.min(x)*1e6, np.max(x)*1e6\n",
        "plt.subplot(1,2,1)\n",
        "plt.imshow(np.abs(field.transpose())**2,extent=extent,cmap='gray')\n",
        "plt.xlabel('y [µm]')\n",
        "plt.ylabel('x [µm]')\n",
        "\n",
        "plt.subplot(1,2,2)\n",
        "plt.plot(x,np.abs(field[500,:])**2)\n",
        "\n",
        "plt.ylabel('intensity')\n",
        "plt.xlabel('x [µm]')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```"
      ],
      "id": "f0294b8d"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}