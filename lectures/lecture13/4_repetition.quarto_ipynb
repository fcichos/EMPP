{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Repetition Meshgrid and Vector Fields\n",
        "format:\n",
        "  live-html:\n",
        "    toc: true\n",
        "    toc-location: right\n",
        "pyodide:\n",
        "  autorun: false\n",
        "  packages:\n",
        "    - matplotlib\n",
        "    - numpy\n",
        "    - scipy\n",
        "---\n",
        "\n",
        "```{pyodide}\n",
        "#| edit: false\n",
        "#| echo: false\n",
        "#| execute: true\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Set default plotting parameters\n",
        "plt.rcParams.update({\n",
        "    'font.size': 12,\n",
        "    'lines.linewidth': 1,\n",
        "    'lines.markersize': 5,\n",
        "    'axes.labelsize': 11,\n",
        "    'xtick.labelsize': 10,\n",
        "    'ytick.labelsize': 10,\n",
        "    'xtick.top': True,\n",
        "    'xtick.direction': 'in',\n",
        "    'ytick.right': True,\n",
        "    'ytick.direction': 'in',\n",
        "})\n",
        "\n",
        "def get_size(w, h):\n",
        "    return (w/2.54, h/2.54)\n",
        "```\n",
        "\n",
        "This time, the exercises are a bit more complicated and perhaps only for the more advanced. You may, however, do some training with the easier repetitions before and come back and test yourself. We will focus on creating visualizations of vector fields using meshgrids and quiver plots. Vector fields are used to represent the spatial distribution of physical quantities like electric fields, fluid velocities, or magnetic fields. By visualizing vector fields, we can gain insights into the behavior of these quantities in different regions of space.\n",
        "\n",
        "**Note that matplotlib and numpy are already imported and may be used with `plt` and `np` respectively.**\n",
        "\n",
        "::: {.callout-note}\n",
        "### Self-Exercise 1: Electric Field of a Point Charge\n",
        "Create a 2D vector field plot of the electric field from a point charge located at the origin. The electric field vectors should point radially outward from the charge, with magnitude proportional to 1/r². This visualization helps understand the spatial distribution of electric fields.\n",
        "\n",
        "The electric field is given by: $\\vec{E}(\\vec{r}) = \\frac{q}{4\\pi\\epsilon_0} \\frac{\\vec{r}}{r^3}$\n",
        "\n",
        "where:\n",
        "\n",
        "- $\\vec{E}$ is the electric field vector\n",
        "- $q$ is the charge\n",
        "- $\\epsilon_0$ is the permittivity of free space\n",
        "- $\\vec{r}$ is the position vector\n",
        "- $r$ is the distance from the charge\n",
        "\n",
        "Look up the `plt.quiver()` function in the [Matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html) for plotting vector fields or check out the hint.\n",
        "\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_1\n",
        "\n",
        "# Create coordinate grid\n",
        "x = np.linspace(-2, 2, 20)\n",
        "y = np.linspace(-2, 2, 20)\n",
        "\n",
        "# Create meshgrid and calculate field components\n",
        "____\n",
        "\n",
        "# Plot vector field\n",
        "____\n",
        "```\n",
        "\n",
        "::: {.hint exercise=\"ex_1\"}\n",
        "1. Use `np.meshgrid(x, y)` to create X, Y grids\n",
        "2. Calculate R = sqrt(X² + Y²) for distance\n",
        "3. Calculate Ex = X/R³ and Ey = Y/R³\n",
        "4. Use `plt.quiver(X, Y, Ex, Ey)` for the vector field\n",
        "5. Remember to avoid division by zero at the origin\n",
        ":::\n",
        "\n",
        "::: {.solution exercise=\"ex_1\"}\n",
        "::: {.callout-note collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Create coordinate grid\n",
        "x = np.linspace(-2, 2, 20)\n",
        "y = np.linspace(-2, 2, 20)\n",
        "\n",
        "# Create meshgrid\n",
        "X, Y = np.meshgrid(x, y)\n",
        "\n",
        "# Calculate distance from origin (add small number to avoid division by zero)\n",
        "R = np.sqrt(X**2 + Y**2 + 1e-16)\n",
        "\n",
        "# Calculate field components\n",
        "Ex = X/R**3\n",
        "Ey = Y/R**3\n",
        "\n",
        "# Create plot\n",
        "plt.figure(figsize=get_size(8, 8))\n",
        "plt.quiver(X, Y, Ex, Ey)\n",
        "plt.xlabel('x position (m)')\n",
        "plt.ylabel('y position (m)')\n",
        "plt.axis('equal')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Optional: Add magnitude plot\n",
        "plt.figure(figsize=get_size(8, 8))\n",
        "E_mag = np.sqrt(Ex**2 + Ey**2)\n",
        "plt.contourf(X, Y, E_mag)\n",
        "plt.colorbar(label='Field Magnitude')\n",
        "plt.xlabel('x position (m)')\n",
        "plt.ylabel('y position (m)')\n",
        "plt.axis('equal')\n",
        "plt.show()\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "::: {.callout-note}\n",
        "### Self-Exercise 2: Standing Wave Pattern\n",
        "Visualize a 2D standing wave pattern that might occur in a square membrane (like a drum head). This type of visualization is useful in understanding wave modes in musical instruments or quantum mechanical systems.\n",
        "\n",
        "The wave function is given by: $\\psi(x,y,t) = \\sin(mx)\\cos(ny)$\n",
        "\n",
        "where:\n",
        "- $m, n$ are mode numbers (integers)\n",
        "- $x, y$ are positions on the membrane\n",
        "- $\\psi$ is the displacement amplitude\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_2\n",
        "\n",
        "# Create coordinate grid\n",
        "x = np.linspace(-np.pi, np.pi, 100)\n",
        "y = np.linspace(-np.pi, np.pi, 100)\n",
        "\n",
        "# Create meshgrid and calculate wave pattern\n",
        "____\n",
        "\n",
        "# Create visualization\n",
        "____\n",
        "```\n",
        "\n",
        "::: {.hint exercise=\"ex_2\"}\n",
        "1. Use `np.meshgrid(x, y)` to create X, Y grids\n",
        "2. Try different mode numbers (m, n) for different patterns\n",
        "3. Use `plt.contourf()` for filled contours\n",
        "4. Add a colorbar to show amplitude scale\n",
        "5. Look up the matplotlib plotting of surfaces with\n",
        "  `ax = plt.subplot(122, projection='3d')`\n",
        "  `surf = ax.plot_surface()`\n",
        ":::\n",
        "\n",
        "::: {.solution exercise=\"ex_2\"}\n",
        "::: {.callout-note collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "\n",
        "\n",
        "x = np.linspace(-np.pi, np.pi, 100)\n",
        "y = np.linspace(-np.pi, np.pi, 100)\n",
        "\n",
        "\n",
        "X, Y = np.meshgrid(x, y)\n",
        "\n",
        "# Set mode numbers\n",
        "m, n = 2, 3\n",
        "\n",
        "psi = np.sin(m*X) * np.cos(n*Y)\n",
        "\n",
        "plt.figure(figsize=get_size(16, 8))\n",
        "\n",
        "plt.subplot(121)\n",
        "plt.contourf(X, Y, psi, levels=20, cmap='RdBu')\n",
        "plt.colorbar(label='Amplitude')\n",
        "plt.xlabel('x position')\n",
        "plt.ylabel('y position')\n",
        "plt.axis('equal')\n",
        "\n",
        "\n",
        "ax = plt.subplot(122, projection='3d')\n",
        "surf = ax.plot_surface(X, Y, psi, cmap='RdBu')\n",
        "#plt.colorbar(surf, label='Amplitude')\n",
        "ax.set_xlabel('x position')\n",
        "ax.set_ylabel('y position')\n",
        "ax.set_zlabel('Amplitude')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::\n",
        "\n",
        "::: {.callout-note}\n",
        "### Self-Exercise 3: Quantum Wave Packet\n",
        "Create a 3D visualization of a Gaussian wave packet, which represents a localized quantum particle. This type of visualization is fundamental in understanding quantum mechanical states and probability distributions.\n",
        "\n",
        "The wave function is given by: $\\psi(x,y) = A\\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2}\\right)$\n",
        "\n",
        "where:\n",
        "- $A$ is the amplitude\n",
        "- $(x_0, y_0)$ is the center position\n",
        "- $\\sigma$ is the width of the packet\n",
        "\n",
        "```{pyodide}\n",
        "#| exercise: ex_3\n",
        "\n",
        "\n",
        "# Create coordinate grid\n",
        "x = np.linspace(-5, 5, 100)\n",
        "y = np.linspace(-5, 5, 100)\n",
        "\n",
        "# Create meshgrid and calculate wave function\n",
        "____\n",
        "\n",
        "# Create 3D visualization\n",
        "____\n",
        "```\n",
        "\n",
        "::: {.hint exercise=\"ex_3\"}\n",
        "1. Use `np.meshgrid(x, y)` to create X, Y grids\n",
        "2. Calculate ψ using the Gaussian formula\n",
        "3. Create both a 3D surface plot and a 2D probability density plot\n",
        "4. Use as the probability density is |ψ|²\n",
        "5. Look up the matplotlib plotting of surfaces with\n",
        "  `ax = plt.subplot(133, projection='3d')`\n",
        "  `surf = ax.plot_surface(X, Y, prob_density, cmap='viridis')`\n",
        ":::\n",
        "\n",
        "::: {.solution exercise=\"ex_3\"}\n",
        "::: {.callout-note collapse=\"false\"}\n",
        "## Solution\n",
        "```{pyodide}\n",
        "\n",
        "x = np.linspace(-5, 5, 100)\n",
        "y = np.linspace(-5, 5, 100)\n",
        "\n",
        "X, Y = np.meshgrid(x, y)\n",
        "\n",
        "x0, y0 = 1.0, 0.0  # center position\n",
        "sigma = 1.0  # width\n",
        "A = 1.0  # amplitude\n",
        "\n",
        "psi = A * np.exp(-((X-x0)**2 + (Y-y0)**2)/(2*sigma**2))\n",
        "\n",
        "prob_density = np.abs(psi)**2\n",
        "\n",
        "plt.figure(figsize=get_size(15, 5))\n",
        "\n",
        "# Wave function amplitude\n",
        "plt.subplot(131)\n",
        "plt.contourf(X, Y, np.real(psi), levels=20, cmap='RdBu')\n",
        "plt.xlabel('x position')\n",
        "plt.ylabel('y position')\n",
        "plt.title('Wave Function')\n",
        "plt.axis('equal')\n",
        "\n",
        "plt.subplot(132)\n",
        "plt.contourf(X, Y, prob_density, levels=20, cmap='viridis')\n",
        "plt.xlabel('x position')\n",
        "plt.ylabel('y position')\n",
        "plt.title('Probability Density')\n",
        "plt.axis('equal')\n",
        "\n",
        "# 3D surface plot\n",
        "ax = plt.subplot(133, projection='3d')\n",
        "surf = ax.plot_surface(X, Y, prob_density, cmap='viridis')\n",
        "ax.set_xlabel('x position')\n",
        "ax.set_ylabel('y position')\n",
        "ax.set_zlabel('Probability Density')\n",
        "ax.set_title('3D View')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        ":::\n",
        ":::\n",
        ":::"
      ],
      "id": "30b48304"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}