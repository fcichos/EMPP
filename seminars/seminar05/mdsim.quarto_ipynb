{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\n",
        "author: \"Frank Cichos\"\n",
        "jupyter: python3\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "crossref:\n",
        "  fig-title: Figure     # (default is \"Figure\")\n",
        "  tbl-title: Tbl     # (default is \"Table\")\n",
        "  title-delim: \"—\"   # (default is \":\")\n",
        "  fig-prefix: \"Figure\"\n",
        "  eq-prefix: Eq.\n",
        "  chapters: true\n",
        "---\n",
        "\n",
        "\n",
        "## Here is the complete code for the molecular dynamics simulation\n",
        "\n",
        "\n",
        "```python\n",
        "# %% Load  modules and initialize\n",
        "from typing_extensions import ParamSpec\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from IPython.display import clear_output\n",
        "import matplotlib.patches as patches\n",
        "plt.rcParams.update({'font.size': 8,\n",
        "                     'lines.linewidth': 1,\n",
        "                     'lines.markersize': 10,\n",
        "                     'axes.labelsize': 10,\n",
        "                     'axes.titlesize': 10,\n",
        "                     'xtick.labelsize' : 10,\n",
        "                     'ytick.labelsize' : 10,\n",
        "                     'xtick.top' : True,\n",
        "                     'xtick.direction' : 'in',\n",
        "                     'ytick.right' : True,\n",
        "                     'ytick.direction' : 'in',\n",
        "                     'figure.facecolor' : 'white',})\n",
        "\n",
        "def get_size(w,h):\n",
        "    return((w/2.54,h/2.54))\n",
        "\n",
        "\n",
        "# %% Load the atom class we did already in the previous seminar\n",
        "class Atom:\n",
        "    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n",
        "        self.id = atom_id\n",
        "        self.type = atom_type\n",
        "        self.position = position\n",
        "        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n",
        "        self.mass = mass\n",
        "        self.force = np.zeros(2)\n",
        "\n",
        "\n",
        "    def add_force(self, force):\n",
        "        \"\"\"Add force contribution to total force on atom\"\"\"\n",
        "        self.force += force\n",
        "\n",
        "    def reset_force(self):\n",
        "        \"\"\"Reset force to zero at start of each step\"\"\"\n",
        "        self.force = np.zeros(2)\n",
        "\n",
        "    def update_position(self, dt):\n",
        "        \"\"\"First step of velocity Verlet: update position\"\"\"\n",
        "        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n",
        "\n",
        "    def update_velocity(self, dt, new_force):\n",
        "        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n",
        "        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n",
        "        self.force = new_force\n",
        "\n",
        "    def apply_periodic_boundaries(self, box_size):\n",
        "            \"\"\"Apply periodic boundary conditions\"\"\"\n",
        "            self.position = self.position % box_size\n",
        "\n",
        "class ForceField:\n",
        "    def __init__(self):\n",
        "        self.parameters = {\n",
        "            'C': {'epsilon': 1.615, 'sigma': 1.36},\n",
        "            'H': {'epsilon': 1.0, 'sigma': 1.0 },\n",
        "            'O': {'epsilon': 1.846, 'sigma': 3.0},\n",
        "        }\n",
        "        self.bond_parameters = {\n",
        "            ('H', 'H'): {'k': 500.0, 'r0': 0.74},  # Example parameters for H2\n",
        "            ('O', 'H'): {'k': 550.0, 'r0': 0.96},  # Example parameters for OH bond\n",
        "        }\n",
        "        self.box_size = None\n",
        "\n",
        "    def calculate_bond_force(self, bond):\n",
        "        \"\"\"Calculate harmonic bond force\"\"\"\n",
        "        r = self.minimum_image_distance(bond.atom1.position, bond.atom2.position)\n",
        "        r_mag = np.linalg.norm(r)\n",
        "\n",
        "        # F = -k(r - r0)∙(r/|r|)\n",
        "        force_mag = -bond.k * (r_mag - bond.r0)\n",
        "        force = force_mag * r/r_mag\n",
        "        return force\n",
        "\n",
        "    def get_pair_parameters(self, type1, type2):\n",
        "        # Apply mixing rules when needed\n",
        "        eps1 = self.parameters[type1]['epsilon']\n",
        "        eps2 = self.parameters[type2]['epsilon']\n",
        "        sig1 = self.parameters[type1]['sigma']\n",
        "        sig2 = self.parameters[type2]['sigma']\n",
        "\n",
        "        # Lorentz-Berthelot mixing rules\n",
        "        epsilon = np.sqrt(eps1 * eps2)\n",
        "        sigma = (sig1 + sig2) / 2\n",
        "\n",
        "        return epsilon, sigma\n",
        "\n",
        "    def minimum_image_distance(self, pos1, pos2):\n",
        "        \"\"\"Calculate minimum image distance between two positions\"\"\"\n",
        "        delta = pos1 - pos2\n",
        "        # Apply minimum image convention\n",
        "        delta = delta - self.box_size * np.round(delta / self.box_size)\n",
        "        return delta\n",
        "\n",
        "    def calculate_lj_force(self, atom1, atom2):\n",
        "        epsilon, sigma = self.get_pair_parameters(atom1.type, atom2.type)\n",
        "        r = self.minimum_image_distance(atom1.position, atom2.position)\n",
        "        r_mag = np.linalg.norm(r)\n",
        "\n",
        "        # Add cutoff distance for stability\n",
        "        if r_mag > 3.5*sigma:\n",
        "            return np.zeros(2)\n",
        "\n",
        "        force_mag = 24 * epsilon * (\n",
        "            2 * (sigma/r_mag)**13\n",
        "            - (sigma/r_mag)**7\n",
        "        )\n",
        "        force = force_mag * r/r_mag\n",
        "        return force\n",
        "\n",
        "\n",
        "# %% Diatomic Molecule Definition\n",
        "class DiatomicMolecule:\n",
        "    def __init__(self, atom1, atom2, bond):\n",
        "        self.atom1 = atom1\n",
        "        self.atom2 = atom2\n",
        "        self.bond = bond\n",
        "\n",
        "\n",
        "# %% Define the MD Simulation master controller class\n",
        "\n",
        "class MDSimulation:\n",
        "    def __init__(self, molecules, forcefield, timestep, box_size):\n",
        "        self.molecules = molecules\n",
        "        self.atoms = [atom for mol in molecules for atom in [mol.atom1, mol.atom2]]\n",
        "        self.forcefield = forcefield\n",
        "        self.forcefield.box_size = box_size\n",
        "        self.timestep = timestep\n",
        "        self.box_size = np.array(box_size)\n",
        "        self.energy_history = []\n",
        "\n",
        "\n",
        "    def calculate_forces(self):\n",
        "        # Reset all forces\n",
        "        for atom in self.atoms:\n",
        "            atom.reset_force()\n",
        "\n",
        "        # Calculate bonded forces\n",
        "        for molecule in self.molecules:\n",
        "            force = self.forcefield.calculate_bond_force(molecule.bond)\n",
        "            molecule.atom1.add_force(force)\n",
        "            molecule.atom2.add_force(-force)\n",
        "\n",
        "        # Calculate non-bonded forces between molecules\n",
        "        for i, mol1 in enumerate(self.molecules):\n",
        "            for mol2 in self.molecules[i+1:]:\n",
        "                # Calculate forces between atoms of different molecules\n",
        "                for atom1 in [mol1.atom1, mol1.atom2]:\n",
        "                    for atom2 in [mol2.atom1, mol2.atom2]:\n",
        "                        force = self.forcefield.calculate_lj_force(atom1, atom2)\n",
        "                        atom1.add_force(force)\n",
        "                        atom2.add_force(-force)\n",
        "\n",
        "    def update_positions_and_velocities(self):\n",
        "        # First step: Update positions using current forces\n",
        "        for atom in self.atoms:\n",
        "            atom.update_position(self.timestep)\n",
        "            # Apply periodic boundary conditions\n",
        "            atom.apply_periodic_boundaries(self.box_size)\n",
        "\n",
        "        # Recalculate forces with new positions\n",
        "        self.calculate_forces()\n",
        "\n",
        "        # Second step: Update velocities using average of old and new forces\n",
        "        for atom in self.atoms:\n",
        "            atom.update_velocity(self.timestep, atom.force)\n",
        "\n",
        "\n",
        "# %% Cell 6\n",
        "def create_grid_atoms(num_atoms, box_size, type=\"H\",mass=1.0, random_offset=0.1):\n",
        "    box_size = np.array(box_size)\n",
        "\n",
        "    # Calculate grid dimensions\n",
        "    n = int(np.ceil(np.sqrt(num_atoms)))\n",
        "    spacing = np.min(box_size) / n\n",
        "\n",
        "    atoms = []\n",
        "    for i in range(num_atoms):\n",
        "        # Calculate grid position\n",
        "        row = i // n\n",
        "        col = i % n\n",
        "\n",
        "        # Base position\n",
        "        pos = np.array([col * spacing + spacing/2,\n",
        "                       row * spacing + spacing/2])\n",
        "\n",
        "        # Add random offset\n",
        "        pos += (np.random.rand(2) - 0.5) * spacing * random_offset\n",
        "\n",
        "        # Create atom\n",
        "        atoms.append(Atom(i, type, pos, mass=mass))\n",
        "\n",
        "    return atoms\n",
        "\n",
        "\n",
        "# %% Create diatomic Molecules\n",
        "#\n",
        "def create_diatomic_molecules(num_molecules, box_size, type1=\"H\", type2=\"H\", mass1=1.0, mass2=1.0):\n",
        "    molecules = []\n",
        "    spacing = np.min(box_size) / np.ceil(np.sqrt(num_molecules))\n",
        "\n",
        "    for i in range(num_molecules):\n",
        "        # Calculate grid position for molecule center\n",
        "        row = i // int(np.ceil(np.sqrt(num_molecules)))\n",
        "        col = i % int(np.ceil(np.sqrt(num_molecules)))\n",
        "        center = np.array([col * spacing + spacing/2, row * spacing + spacing/2])\n",
        "\n",
        "        # Create atoms with small random displacement for initial bond length\n",
        "        displacement = np.random.randn(2) * 0.1\n",
        "        atom1 = Atom(2*i, type1, center + displacement, mass=mass1)\n",
        "        atom2 = Atom(2*i+1, type2, center - displacement, mass=mass2)\n",
        "\n",
        "        # Create bond\n",
        "        ff = ForceField()\n",
        "        bond_params = ff.bond_parameters[(type1, type2)]\n",
        "        bond = Bond(atom1, atom2, bond_params['k'], bond_params['r0'])\n",
        "\n",
        "        molecules.append(DiatomicMolecule(atom1, atom2, bond))\n",
        "\n",
        "    return molecules\n",
        "\n",
        "# %% Cell 7\n",
        "def set_temperature(atoms, target_temperature):\n",
        "    N = len(atoms)      # number of atoms\n",
        "    Nf = 2 * N         # degrees of freedom in 2D\n",
        "\n",
        "    # Calculate current kinetic energy\n",
        "    current_ke = sum(0.5 * atom.mass * np.sum(atom.velocity**2) for atom in atoms)\n",
        "    current_temperature = 2 * current_ke / Nf  # kb = 1 in reduced units\n",
        "    print(current_temperature)\n",
        "    # Calculate scaling factor\n",
        "    scale_factor = np.sqrt(target_temperature / current_temperature)\n",
        "\n",
        "    # Scale velocities\n",
        "    for atom in atoms:\n",
        "        atom.velocity *= scale_factor\n",
        "\n",
        "\n",
        "def initialize_velocities(atoms, temperature, seed=None):\n",
        "    if seed is not None:\n",
        "        np.random.seed(seed)\n",
        "\n",
        "    N = len(atoms)  # number of atoms\n",
        "    dim = 2         # 2D simulation\n",
        "\n",
        "    # Generate random velocities from normal distribution\n",
        "    velocities = np.random.normal(0, np.sqrt(temperature), size=(N, dim))\n",
        "\n",
        "    # Remove center of mass motion\n",
        "    total_momentum = np.sum([atom.mass * velocities[i] for i, atom in enumerate(atoms)], axis=0)\n",
        "    total_mass = np.sum([atom.mass for atom in atoms])\n",
        "    cm_velocity = total_momentum / total_mass\n",
        "\n",
        "    # Assign velocities to atoms\n",
        "    for i, atom in enumerate(atoms):\n",
        "        atom.velocity = velocities[i] - cm_velocity\n",
        "\n",
        "    # Scale velocities to exact temperature\n",
        "    set_temperature(atoms, temperature)\n",
        "\n",
        "    return atoms\n",
        "\n",
        "# %% run the simulation w\n",
        "\n",
        "T=5\n",
        "dt = 0.01\n",
        "box_size = np.array([50.0, 50.0])\n",
        "num_molecules = 100\n",
        "molecules = create_diatomic_molecules(num_molecules, box_size, \"H\", \"H\")\n",
        "ff = ForceField()\n",
        "sim = MDSimulation(molecules, ff, dt, box_size)\n",
        "\n",
        "# Initialize velocities for all atoms\n",
        "atoms = [atom for mol in molecules for atom in [mol.atom1, mol.atom2]]\n",
        "initialize_velocities(atoms, temperature=T)\n",
        "\n",
        "fig, ax = plt.subplots(1,1,figsize=(6,6))\n",
        "\n",
        "for step in range(1000):\n",
        "    clear_output(wait=True)\n",
        "    set_temperature(atoms, target_temperature=T)\n",
        "    sim.update_positions_and_velocities()\n",
        "\n",
        "\n",
        "    positions = [atom.position for atom in sim.atoms]\n",
        "    x_coords = [pos[0] for pos in positions]\n",
        "    y_coords = [pos[1] for pos in positions]\n",
        "\n",
        "    circle=patches.Circle((x_coords[0],y_coords[0]),ff.parameters[atoms[0].type][\"sigma\"],edgecolor=\"white\",fill=False)\n",
        "    ax.add_patch(circle)\n",
        "    ax.scatter(x_coords, y_coords,color=\"red\")\n",
        "    ax.set_xlim(0, box_size[0])\n",
        "    ax.set_ylim(0, box_size[1])\n",
        "    ax.axis(\"off\")\n",
        "\n",
        "    display(fig)\n",
        "\n",
        "    ax.clear()\n",
        "# %% Cell 8\n",
        "#\n",
        "\n",
        "vx=np.array([atom.velocity for atom in atoms])\n",
        "\n",
        "vx.reshape(200,2)\n",
        "plt.hist(vx[:,0],bins=20)\n",
        "```"
      ],
      "id": "d1ebf3e8"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}