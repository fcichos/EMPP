{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\n",
        "author: \"Frank Cichos\"\n",
        "jupyter: python3\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "---\n",
        "\n",
        "## Molecular Dynamics Simulations\n",
        "\n",
        "Real molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\n",
        "\n",
        "Before we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation.\n",
        "\n",
        "\n",
        "## Basic Physical Concepts\n",
        "\n",
        "### Newton's Equations of Motion\n",
        "\n",
        "The motion of particles in a molecular dynamics simulation is governed by Newton's equations of motion:\n",
        "\n",
        "$$m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $m_i$ is the mass of particle $i$\n",
        "- $\\vec{r}_i$ is the position of particle $i$\n",
        "- $\\vec{F}_i$ is the force acting on particle $i$\n",
        "\n",
        "The force acting on a particle is the sum of all forces acting on it:\n",
        "\n",
        "$$\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}$$\n",
        "\n",
        "where $\\vec{F}_{ij}$ is the force acting on particle $i$ due to particle $j$.\n",
        "\n",
        "### Potential Energy Functions and Forces\n",
        "The force $\\vec{F}_{ij}$ is usually derived from a potential energy function and may result from a variety of interactions, such as:\n",
        "\n",
        "- Bonded interactions\n",
        "  - bond stretching\n",
        "      ![Bond Stretching](img/bond.png){width=30%}\n",
        "  - bond angle bending\n",
        "    ![Bond Stretching](img/bond_angle.png){width=30%}\n",
        "  - torsional interactions\n",
        "    ![Bond Stretching](img/dihedral.png){width=30%}\n",
        "\n",
        "\n",
        "- Non-bonded interactions\n",
        "  - electrostatic interactions\n",
        "  - van der Waals interactions\n",
        "\n",
        "- External forces\n",
        "\n",
        "We will implement some of them but not all of them.\n",
        "\n",
        "#### Lennard-Jones Potential\n",
        "\n",
        "The most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n",
        "\n",
        "$$V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$$\n",
        "\n",
        "and\n",
        "\n",
        "$$F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $\\epsilon$ is the depth of the potential well\n",
        "- $\\sigma$ is the distance at which the potential is zero\n",
        "- $r$ is the distance between particles\n",
        "\n",
        "The Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid."
      ],
      "id": "a52457fc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "plt.rcParams.update({'font.size': 8,\n",
        "                     'lines.linewidth': 1,\n",
        "                     'lines.markersize': 10,\n",
        "                     'axes.labelsize': 10,\n",
        "                     'axes.titlesize': 10,\n",
        "                     'xtick.labelsize' : 10,\n",
        "                     'ytick.labelsize' : 10,\n",
        "                     'xtick.top' : True,\n",
        "                     'xtick.direction' : 'in',\n",
        "                     'ytick.right' : True,\n",
        "                     'ytick.direction' : 'in',})\n",
        "\n",
        "def get_size(w,h):\n",
        "    return((w/2.54,h/2.54))"
      ],
      "id": "47481922",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| fig-align: center\n",
        "def lennard_jones(r, epsilon=1, sigma=1):\n",
        "    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n",
        "\n",
        "r = np.linspace(0.8, 3, 1000)\n",
        "V = lennard_jones(r)\n",
        "\n",
        "plt.figure(figsize=get_size(8, 6),dpi=150)\n",
        "plt.plot(r, V, 'b-', linewidth=2)\n",
        "plt.grid(True)\n",
        "plt.xlabel('r/σ')\n",
        "plt.ylabel('V/ε')\n",
        "plt.title('Lennard-Jones Potential')\n",
        "plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\n",
        "plt.ylim(-1.5, 3)\n",
        "plt.show()"
      ],
      "id": "d49a7369",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The figure above shows the Lenard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance $r = \\sigma$ and has a minimum at $r = 2^{1/6}\\sigma$. The potential energy is positive for $r < \\sigma$ and negative for $r > \\sigma$.\n",
        "\n",
        "\n",
        "::: {.callout-note}\n",
        "## Values for atomic hydrogen\n",
        "For atomic hydrogen (H), typical Lennard-Jones parameters are:\n",
        "\n",
        "- $\\sigma \\approx 2.38$ Å = $2.38 \\times 10^{-10}$ meters\n",
        "- $\\epsilon \\approx 0.0167$ kcal/mol = $1.16 \\times 10^{-21}$ joules\n",
        ":::\n",
        "\n",
        "Later, if we manage to advance to some more complicated systems, we may want to introduce:\n",
        "\n",
        "1. force in bonds between two atoms\n",
        "2. force in bond angles between three atoms\n",
        "3. force in dihedral angles between four atoms\n",
        "\n",
        "But for now, we will stick to the Lennard-Jones potential.\n",
        "\n",
        "\n",
        "## Integrating Newtons Euqation of Motion\n",
        "When we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n",
        "\n",
        "### Euler Method\n",
        "To obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function $f(x)$ around a point $x_0$ is providing an approximation of the function in the vicinity of $x_0$. It is given by:\n",
        "\n",
        "$$f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots$$\n",
        "\n",
        "where $f'(x_0)$ is the first derivative of $f(x)$ at $x_0$, $f''(x_0)$ is the second derivative of $f(x)$ at $x_0$, and so on. We can demonstrate that by expanding a sine function around $x_0 = 0$:\n",
        "\n",
        "$$\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots$$\n",
        "\n",
        "Plotting this yields:"
      ],
      "id": "f2547875"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| fig-align: center\n",
        "x = np.linspace(-2*np.pi, 2*np.pi, 1000)\n",
        "y = np.sin(x)\n",
        "y_taylor = x - 1/6*x**3\n",
        "\n",
        "plt.figure(figsize=get_size(8, 6),dpi=150)\n",
        "plt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\n",
        "plt.plot(x, y_taylor, 'r--', label='Taylor expansion', linewidth=2)\n",
        "plt.grid(True)\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('f(x)')\n",
        "plt.xlim(-2,2)\n",
        "plt.ylim(-2,2)\n",
        "plt.title('Taylor Expansion of sin(x)')\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "82834568",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The expansion is therefore a good approximation in a region close to $x_0$.\n",
        "\n",
        "### Velocity Verlet Algorithm\n",
        "The velocity Verlet algorithm is a second-order algorithm that is more accurate than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors\n",
        "\n",
        "$$\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)$$\n",
        "\n",
        "\n",
        "The higher order terms in the Taylor expansion are neglected, which results in an error of order $\\Delta t^3$. As compared to that the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n",
        "\n",
        "$$\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)$$\n",
        "\n",
        "and is therefore only first order accurate with an error of order $\\Delta t^2$.\n",
        "\n",
        "\n",
        "The velocity Verlet algorithm consists of three steps:\n",
        "\n",
        "1. Update positions:\n",
        "   $\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2$\n",
        "\n",
        "2. Calculate new forces:\n",
        "   $\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))$\n",
        "\n",
        "3. Update velocities:\n",
        "   $\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t$\n",
        "\n",
        "where:\n",
        "- $\\mathbf{r}$ is the position vector\n",
        "- $\\mathbf{v}$ is the velocity vector\n",
        "- $\\mathbf{F}$ is the force vector\n",
        "- $m$ is the mass\n",
        "- $\\Delta t$ is the timestep\n",
        "\n",
        "\n",
        "### Simple Integration Example: Free Fall\n",
        "\n",
        "Let's start and try to integrate the equation of motion for a particle in free fall with the help of the Velocity Verlet algorithm. The only force acting on the particle is gravity. The equation of motion is:\n",
        "\n",
        "Newton's equation of motion:\n",
        "$\\mathbf{F} = m\\mathbf{a}$\n",
        "\n",
        "For gravity:\n",
        "$\\mathbf{F} = -mg\\hat{\\mathbf{y}}$\n",
        "\n",
        "Therefore:\n",
        "$\\ddot{y} = -g$\n",
        "\n",
        "The analytical solution is:\n",
        "\n",
        "  - Position: $y(t) = y_0 + v_0t - \\frac{1}{2}gt^2$\n",
        "  - Velocity: $v(t) = v_0 - gt$"
      ],
      "id": "bfae0a1d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-align: center\n",
        "# Parameters\n",
        "\n",
        "g = 9.81  # m/s^2\n",
        "dt = 0.01  # time step\n",
        "t_max = 2.0  # total simulation time\n",
        "steps = int(t_max/dt)\n",
        "\n",
        "# Initial conditions\n",
        "y0 = 20.0  # initial height\n",
        "v0 = 0.0   # initial velocity\n",
        "\n",
        "\n",
        "# Arrays to store results\n",
        "t = np.zeros(steps)\n",
        "y = np.zeros(steps)\n",
        "v = np.zeros(steps)\n",
        "a = np.zeros(steps)\n",
        "\n",
        "# Initial values\n",
        "y[0] = y0\n",
        "v[0] = v0\n",
        "a[0] = -g\n",
        "\n",
        "# Velocity Verlet integration\n",
        "for i in range(1, steps):\n",
        "    t[i] = i * dt\n",
        "    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n",
        "    a_new = -g                                          # new acceleration (assuming constant gravity)\n",
        "    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt         # update velocity\n",
        "    a[i] = a_new                                        # store new acceleration\n",
        "\n",
        "y_analytical = y0 + v0*t - 0.5*g*t**2\n",
        "plt.figure(figsize=get_size(8, 6), dpi=150)\n",
        "plt.plot(t, y)\n",
        "plt.plot(t, y_analytical, 'r--')\n",
        "\n",
        "plt.xlabel('Time (s)')\n",
        "plt.ylabel('Height (m)')\n",
        "plt.title('Free Fall Motion')\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "ed51b087",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/fci/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}